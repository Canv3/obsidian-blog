<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：16. 错误与异常 | PrintLove</title><meta name=keywords content="program_golang"><meta name=description content="学到什么 什么是错误？ 如何创建错误？ 如何处理错误？ errors 包的使用？ 什么是异常？ 如何处理异常？ defer 关键字的作用？ recover 函数的使用？ 什么是错误 在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。
在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 try/catch 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。
创建错误 这里所说的创建错误，实际上就是去实现错误接口，接口如下：
type error interface { Error() string } 该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 Golang接口。
1. errors.New Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 error 接口，它有函数帮你处理，如下：
import &#34;errors&#34; var ErrNotFound = errors.New(&#34;not found&#34;) 导入 errors 包，调用 New 函数创建了一个错误并保存到 ErrNotFound 变量，该错误信息为 not found 。
2. fmt.Errorf fmt 标准包内也有一个创建错误的函数 Errorf ，该函数可以使用占位符设置错误信息，比 errors.New 函数更灵活。
import &#34;fmt&#34; var ErrHuman = fmt.Errorf(&#34;%s不符合我们人类要求&#34;, &#34;老苗&#34;) 3."><meta name=author content="Evan Miao"><link rel=canonical href=https://www.printlove.cn/golang-error/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：16. 错误与异常"><meta property="og:description" content="学到什么 什么是错误？ 如何创建错误？ 如何处理错误？ errors 包的使用？ 什么是异常？ 如何处理异常？ defer 关键字的作用？ recover 函数的使用？ 什么是错误 在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。
在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 try/catch 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。
创建错误 这里所说的创建错误，实际上就是去实现错误接口，接口如下：
type error interface { Error() string } 该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 Golang接口。
1. errors.New Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 error 接口，它有函数帮你处理，如下：
import &#34;errors&#34; var ErrNotFound = errors.New(&#34;not found&#34;) 导入 errors 包，调用 New 函数创建了一个错误并保存到 ErrNotFound 变量，该错误信息为 not found 。
2. fmt.Errorf fmt 标准包内也有一个创建错误的函数 Errorf ，该函数可以使用占位符设置错误信息，比 errors.New 函数更灵活。
import &#34;fmt&#34; var ErrHuman = fmt.Errorf(&#34;%s不符合我们人类要求&#34;, &#34;老苗&#34;) 3."><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/golang-error/"><meta property="og:image" content="https://images.unsplash.com/photo-1589652717521-10c0d092dea9?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw4fHxlcnJvcnxlbnwwfDB8fHwxNzAzMDc4MDgyfDA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-29T10:10:56+08:00"><meta property="article:modified_time" content="2021-09-29T10:10:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1589652717521-10c0d092dea9?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw4fHxlcnJvcnxlbnwwfDB8fHwxNzAzMDc4MDgyfDA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：16. 错误与异常"><meta name=twitter:description content="学到什么 什么是错误？ 如何创建错误？ 如何处理错误？ errors 包的使用？ 什么是异常？ 如何处理异常？ defer 关键字的作用？ recover 函数的使用？ 什么是错误 在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。
在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 try/catch 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。
创建错误 这里所说的创建错误，实际上就是去实现错误接口，接口如下：
type error interface { Error() string } 该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 Golang接口。
1. errors.New Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 error 接口，它有函数帮你处理，如下：
import &#34;errors&#34; var ErrNotFound = errors.New(&#34;not found&#34;) 导入 errors 包，调用 New 函数创建了一个错误并保存到 ErrNotFound 变量，该错误信息为 not found 。
2. fmt.Errorf fmt 标准包内也有一个创建错误的函数 Errorf ，该函数可以使用占位符设置错误信息，比 errors.New 函数更灵活。
import &#34;fmt&#34; var ErrHuman = fmt.Errorf(&#34;%s不符合我们人类要求&#34;, &#34;老苗&#34;) 3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：16. 错误与异常","item":"https://www.printlove.cn/golang-error/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：16. 错误与异常","name":"Go基础系列：16. 错误与异常","description":"学到什么 什么是错误？ 如何创建错误？ 如何处理错误？ errors 包的使用？ 什么是异常？ 如何处理异常？ defer 关键字的作用？ recover 函数的使用？ 什么是错误 在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。\n在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 try/catch 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。\n创建错误 这里所说的创建错误，实际上就是去实现错误接口，接口如下：\ntype error interface { Error() string } 该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 Golang接口。\n1. errors.New Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 error 接口，它有函数帮你处理，如下：\nimport \u0026#34;errors\u0026#34; var ErrNotFound = errors.New(\u0026#34;not found\u0026#34;) 导入 errors 包，调用 New 函数创建了一个错误并保存到 ErrNotFound 变量，该错误信息为 not found 。\n2. fmt.Errorf fmt 标准包内也有一个创建错误的函数 Errorf ，该函数可以使用占位符设置错误信息，比 errors.New 函数更灵活。\nimport \u0026#34;fmt\u0026#34; var ErrHuman = fmt.Errorf(\u0026#34;%s不符合我们人类要求\u0026#34;, \u0026#34;老苗\u0026#34;) 3.","keywords":["program_golang"],"articleBody":"学到什么 什么是错误？ 如何创建错误？ 如何处理错误？ errors 包的使用？ 什么是异常？ 如何处理异常？ defer 关键字的作用？ recover 函数的使用？ 什么是错误 在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。\n在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 try/catch 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。\n创建错误 这里所说的创建错误，实际上就是去实现错误接口，接口如下：\ntype error interface { Error() string } 该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 Golang接口。\n1. errors.New Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 error 接口，它有函数帮你处理，如下：\nimport \"errors\" var ErrNotFound = errors.New(\"not found\") 导入 errors 包，调用 New 函数创建了一个错误并保存到 ErrNotFound 变量，该错误信息为 not found 。\n2. fmt.Errorf fmt 标准包内也有一个创建错误的函数 Errorf ，该函数可以使用占位符设置错误信息，比 errors.New 函数更灵活。\nimport \"fmt\" var ErrHuman = fmt.Errorf(\"%s不符合我们人类要求\", \"老苗\") 3. 自定义错误类型 如果上述两种方式你觉得还不够灵活，那可以自定义错误类型。\ntype ErrorPathNotExist struct { Filename string } func (*ErrorPathNotExist) Error() string { return \"文件路径不存在\" } var ErrNotExist error = \u0026ErrorPathNotExist{ Filename: \"./main.go\", } 自定义了一个 ErrorPathNotExist 结构体，该结构体实现了 error 接口。 创建了一个 ErrNotExist 错误类型变量。 这种如果不明白具体怎么应用，不着急，往下看。\n补充知识点：如果方法的接收者没有被使用可以直接省略掉，例：func (*ErrorPathNotExist) ，不省略的话就是这样：func (e *ErrorPathNotExist) ，当然也可以使用下划线 \"_\" 代替 \"e\" 只是没有必要性。\n打印错误 在项目开发中，错误常常通过函数或方法的返回值携带，返回的位置也通常被放置在最后一位。\n// error/file.go package main import \"io/ioutil\" // 读取文件内容 func LoadConfig() (string, error) { filename := \"./config.json\" b, err := ioutil.ReadFile(filename) if err != nil { return \"\", err } content := string(b) if len(content) == 0 { return \"\", errors.New(\"内容为空\") } return content, nil } ReadFile 函数读取 \"config.json\" 文件内容。 (string, error) 返回两个值，第一个为文件内容，第二个为错误。 err != nil 用于判断是否有错误，如果有 return 直接返回。 string(b) 变量 b 的类型为 []byte ，该操作是将 []byte 类型转为 string 。 增加了一个“内容为空”的错误判断，该错误也可以直接保存到变量中返回。 var ErrEmpty = errors.New(\"内容为空\") func LoadConfig() (string, error) { // ... return \"\", ErrEmpty // ... } 现在假设 \"config.json\" 文件不存在，调用 LoadConfig 函数看看结果。\npackage main import ( \"fmt\" \"log\" ) func main() { content, err := LoadConfig() if err != nil { log.Fatal(err) } fmt.Println(\"内容：\", content) } // 输出 2021/09/23 16:57:25 open ./config.json: The system cannot find the file specified. 当 err 不等于 nil 时，打印错误，并退出程序。 log 标准包包含打印日志的函数集。 log.Fatal 函数打印日志，并终止程序向下执行。 输出的错误消息显示没有找到指定的文件。 打印错误时，也可以使用 fmt 包，例如：fmt.Println(err) ，只是输出信息没 log 包多。 os.Exit 该函数通知程序退出，并且该函数之后的逻辑将不会被执行。在调用时需要指定退出码，为 0 时，表示正常退出程序。\nos.Exit(0) 不主动调用该函数，即程序从 main 函数自然结束时，默认的退出码为 0。在使用编写工具时或许能看到成功的退出码信息，例如我使用的是 Goland，执行代码后输出的结果末尾会显示如下信息。\nProcess finished with exit code 0 如果不正常退出，退出码则为非 0，通常使用 1 表示未知错误。\nos.Exit(1) 在使用 log.Fatal 函数时，内部就调用了 os.Exit(1) 。\n错误加工 1. 错误拼接 在返回错误时，如果想携带附加的错误消息时，可以使用 fmt.Errorf ，现在修改 LoadConfig 函数。\nfunc LoadConfig() (string, error) { filename := \"./config.json\" b, err := ioutil.ReadFile(filename) if err != nil { return \"\", fmt.Errorf(\"读取文件出错:%v\", err) } // ... } %v 占位符表示获取数据的值，在这块表示错误消息，后续会详细讲解占位符的使用。\n现在重新执行上面的 main 函数，还是假设 \"config.json\" 文件不存在。\n// ... content, err := LoadConfig() if err != nil { log.Fatal(err) } //... // 输出 2021/09/24 11:37:33 读取文件出错:open ./config.json: The system cannot find the file specified. LoadConfig 函数返回的 err 变量中携带了附加的错误消息，但这样有个问题，附加的错误和原始错误消息杂糅在一块导致不能分离。\n2. 错误嵌套和 errors.Unwrap 上面所说的”错误消息杂糅在一块导致不能分离“问题，如果还没有明白的话，可以再看看这块，你应该就豁然开朗了。\n错误嵌套就类似上图，err1 嵌套类 err2 ，err2 也可以继续嵌套。如果想从 err1 中获取 err2 就剥一层，类似洋葱一样，一层一层往里找。\n那怎么实现这种嵌套关系呢，还是使用 fmt.Errorf 函数，只是使用另外一个占位符 %w ，w 的英文全名就是 wrap 。\n继续修改 LoadConfig 函数，如下：\nfunc LoadConfig() (string, error) { filename := \"./config.json\" b, err := ioutil.ReadFile(filename) if err != nil { return \"\", fmt.Errorf(\"读取文件出错:%w\", err) } // ... } 现在再执行 main 函数，即调用 LoadConfig 该函数，并打印错误。\n2021/09/24 18:07:14 读取文件出错:open ./config.json: The system cannot find the file specified. 是不是发现错误结果没有变化，那修改下 main 函数。\npackage main import ( \"errors\" \"fmt\" \"log\" ) func main() { content, err := LoadConfig() if err != nil { log.Fatal(errors.Unwrap(err)) } fmt.Println(\"内容：\", content) } // 输出 2021/09/24 18:11:09 open ./config.json: The system cannot find the file specified. 在打印错误时，增加了一个 errors.Unwrap 函数，该函数就是用来取出嵌套的错误，再看看输出的结果，附加的错误信息”读取文件出错:“已经没有了。\n3. 自定义错误类型 在上面讲过了如何自定义错误类型，现在讲讲如何应用你自定义的错误，接下来将 LoadConfig 函数中的内容为空的错误改为自定义错误类型。\nfunc LoadConfig() (string, error) { filename := \"./config.json\" // ... if len(content) == 0 { return \"\", \u0026FileEmptyError{ Filename: filename, Err: errors.New(\"内容为空\"), } } return content, nil } FileEmptyError 是自定义的错误类型，同样的实现 error 接口。\ntype FileEmptyError struct { Filename string Err error } func (e *FileEmptyError) Error() string { return fmt.Sprintf(\"%s %v\", e.Filename, e.Err) } 现在调用 LoadConfig 函数，现在假设 \"config.json\" 文件存在，但内容为空，结果如下：\ncontent, err := LoadConfig() if err != nil { if v, ok := err.(*FileEmptyError); ok { fmt.Println(\"Filename:\", v.Filename) } log.Fatal(err) } // 输出 Filename: ./config.json 2021/09/27 14:36:40 ./config.json 内容为空 将 err 变量的接口类型推断为 *FileEmptyError 类型，并输出 Filename 字段。 打印自定义错误内容。\n如果想使用 errors.Unwrap 函数 , 就需要实现 Wrapper 接口，fmt.Errorf 函数中的 %w 占位符底层实现好了此接口。 type Wrapper interface { // Unwrap returns the next error in the error chain. // If there is no next error, Unwrap returns nil. Unwrap() error } 只需要我们实现了 Unwrap 方法就可以。\nfunc (e *FileEmptyError) Unwrap() error { return e.Err } 下来自行去实验，我在这就不罗嗦了。\n错误判断 对于一个函数或方法，返回的错误常常不止一个错误结果，如果对于不同的错误结果你想有不同的处理逻辑，那这个时候就要对错误结果进行判断。\n// ... var ( ErrNotFoundRequest = errors.New(\"404\") ErrBadRequest = errors.New(\"请求异常\") ) func GetError() error { // ... // 错误 1 return ErrNotFoundRequest // ... // 错误 2 return ErrBadRequest // ... // 错误 3 path := \"https://printlove.com\" return fmt.Errorf(\"%s:%w\", path, ErrNotFoundRequest) // ... } GetError 函数没有写具体逻辑，只展示了 3 个错误的返回，下来看看如何对这几种情况进行判断。\n1. 最简单 \"==\" 最简单的就是使用”==“判断错误结果。\nerr := GetError() if err == ErrNotFoundRequest { // 错误 1 } else if err == ErrBadRequest { // 错误 2 } 对于这种判断方式有个问题，“错误 3\" 是不符合这两个 if 判断的，但从错误分类上说，它属于 ErrNotFoundRequest 错误，只是拼接了请求地址数据 path ，下来往下看另外一种判断方式。\n2. errors.Is 使用 errors.Is 函数解决“错误 3”的判断问题，下来分析为什么？\n“错误 3”中使用了占位符 %w，它就是将 ErrNotFoundRequest 错误嵌入其中，**Is 函数的作用就是一层层的对错误进行剥离判断**，直到成功或没有嵌套的错误为止，没明白的话可以结合上面的图。\n函数定义如下：\nfunc Is(err, target error) bool err 参数为要判断的错误。 target 参数为要比对的错误对象。\n使用如下： err := GetError() if errors.Is(err, ErrNotFoundRequest) { // 错误 1,错误3 } else if errors.Is(err, ErrBadRequest) { // 错误 2 } 在具体项目中，调用函数或方法时，我们不知道底层是否进行了错误嵌套，如果不明确的话就统一使用 Is 函数。 错误 1 和 错误 2 没有嵌套也可以判断。 3. errors.As 这个和 errors.Is 函数类似，不同点就是该函数只判断错误类型，而 errors.Is 函数不仅判断类型，也要判断值（错误消息）。\n// error/as.go package main import ( \"errors\" \"fmt\" ) type ErrorString struct { s string } func (e *ErrorString) Error() string { return e.s } func main() { var targetErr *ErrorString err := fmt.Errorf(\"new error:[%w]\", \u0026ErrorString{s: \"target err\"}) fmt.Println(errors.As(err, \u0026targetErr)) } // 输出 true targetErr 变量有几点要求：\n无需初始化。 必须是指针类型，并且实现了 error 接口。 As 函数不接受 nil ，因此不能直接使用 targetErr 变量，要使用其引用 \u0026targetErr。 什么是异常 错误就是上述所讲的，它的出现不会导致程序异常退出。\n那什么情况会异常退出呢？比如：\n下标越界 除数为 0 等等 通常该异常是你没留意到代码问题而抛出，当然你可以可以主动抛出。\npanic 使用 panic 函数可以主动抛出异常，该函数格式如下：\nfunc panic(v interface{}) v 参数为空接口类型，那就说明可以接受任意类型数据。 例：\npanic(\"我是异常\") // 输出 panic: 我是异常 goroutine 1 [running]: main.main() C:/workspace/go/src/gobasic/panic/panic.go:4 +0x45 exit status 2 从输出的结果上可以看出几点：\n打印出具体的异常位置，这些信息称作堆栈信息。 程序终止，退出码为 2。 处理异常 不管是主动抛出异常，还是你程序哪块有 bug 被动抛出异常，这些在我们写项目时都是很严重的问题，因为它会导致我们的程序异常退出。\n在其它语言中，通过 try/catch 机制可以捕捉异常来保证程序的正常运行，那在 Go 语言中使用 recover 函数捕捉异常。\n在学习这个函数前，先要了解另外一个关键字 defer 。\n1. defer 它不是函数，只是一个关键字。该关键字后面所跟的语句将延迟执行，在所在函数或方法正常结束时或出现异常中断时，再提前执行。\npackage main import \"fmt\" func main() { defer func() { fmt.Println(\"defer\") }() fmt.Println(\"main\") panic(\"panic\") } // 输出 main defer panic: panic ... defer 关键字后面跟了一个匿名函数调用，有名字的函数当然也可以。 遇到 defer 关键字，后面的语句会延迟执行，因此先输出 \"main\" 字符串。 panic 抛出异常，因此在退出前先执行 defer 语句。 如果调用了 os.Exit 函数，defer 后的语句将不会执行。 如果在一个函数或方法中出现了多个 defer 语句，那会采用先进后出原则，即先出现的 defer 语句后执行，后出现的先执行。\n例：\npackage main import \"fmt\" func Fun1() { fmt.Println(\"猜我啥时候输出？\") } func main() { defer func() { fmt.Println(\"defer\") }() defer Fun1() fmt.Println(\"main\") panic(\"panic\") } // 输出 main 猜我啥时候输出？ defer panic: panic ... 现在讲了 defer 关键字的概念，可能还不知道实际中什么地方用到，我现在举个例子。\n// defer/main.go // 拷贝文件 // srcName 路径文件拷贝到 dstName 路径文件 func CopyFile(srcName, dstName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() return io.Copy(dst, src) } 代码中有两个 defer 关键字，后面的语句用来关闭文件释放资源。\n如果不用此关键字，关闭文件的 Close 函数就必须写在 io.Copy 函数后，因为该函数还要使用文件资源，提前关闭了，就完蛋了。所以，使用 defer 关键字后就会延迟执行，因此就不需要考虑文件什么时候被使用。\n当然也不是只有这一种情况应用，只要记住，在函数或方法结束前你才想处理的语句都可以使用 defer 关键字。\n2. recover 了解了 defer 关键字后就明白了，在程序出现异常之前 defer 语句先被执行，因此在 defer 后的语句就可以提前拦截异常。\n// panic/recover.go package main import \"fmt\" func main() { defer func() { if err := recover(); err != nil { fmt.Println(\"我捕捉的：\", err) fmt.Println(\"我好好的\") } }() panic(\"我是异常\") } // 输出 我捕捉的： 我是异常 我好好的 recover 返回异常信息。 不管是主动抛出异常，还是被动的，recover 函数都能捕捉，这样以保证程序的正常进行。\n假如函数 A 调用了很多函数，这些函数又调用了很多，只要下面被调用的函数出现异常，函数 A 中的 recover 函数将都可以捕捉到。但其中还是有个特例， Goroutine 中出现的异常是无法被捕捉到的，必须在新的 Goroutine 中重新使用 recover 函数，这个让人期待的知识点后续会讲。\n总结 本篇讲解了两个概念，”错误“和”异常“ ，这两个概念很重要，一定要掌握明白。还有一点，在处理错误时，有时候发觉错误结果对于我们没用，那这个时候就可以忽略掉。\n我写的时候也想尽可能的讲明白，有些地方就会啰嗦些。\n","wordCount":"1070","inLanguage":"zh","image":"https://images.unsplash.com/photo-1589652717521-10c0d092dea9?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw4fHxlcnJvcnxlbnwwfDB8fHwxNzAzMDc4MDgyfDA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-09-29T10:10:56+08:00","dateModified":"2021-09-29T10:10:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/golang-error/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：16. 错误与异常</h1><div class=post-meta><span title='2021-09-29 10:10:56 +0800 CST'>2021-09-29</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a16.%20%e9%94%99%e8%af%af%e4%b8%8e%e5%bc%82%e5%b8%b8.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#什么是错误>什么是错误</a></li><li><a href=#创建错误>创建错误</a><ul><li><a href=#1-errorsnew>1. errors.New</a></li><li><a href=#2-fmterrorf>2. fmt.Errorf</a></li><li><a href=#3-自定义错误类型>3. 自定义错误类型</a></li></ul></li><li><a href=#打印错误>打印错误</a><ul><li><a href=#osexit>os.Exit</a></li></ul></li><li><a href=#错误加工>错误加工</a><ul><li><a href=#1-错误拼接>1. 错误拼接</a></li><li><a href=#2-错误嵌套和-errorsunwrap>2. 错误嵌套和 errors.Unwrap</a></li><li><a href=#3-自定义错误类型-1>3. 自定义错误类型</a></li></ul></li><li><a href=#错误判断>错误判断</a><ul><li><a href=#1-最简单->1. 最简单 "<code>==</code>"</a></li><li><a href=#2-errorsis>2. errors.Is</a></li><li><a href=#3-errorsas>3. errors.As</a></li></ul></li><li><a href=#什么是异常>什么是异常</a></li><li><a href=#panic>panic</a></li><li><a href=#处理异常>处理异常</a><ul><li><a href=#1-defer>1. defer</a></li><li><a href=#2-recover>2. recover</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>什么是错误？</li><li>如何创建错误？</li><li>如何处理错误？</li><li> <code>errors</code> 包的使用？</li><li>什么是异常？</li><li>如何处理异常？</li><li><code>defer</code> 关键字的作用？</li><li><code>recover</code> 函数的使用？</li></ol><h2 id=什么是错误>什么是错误<a hidden class=anchor aria-hidden=true href=#什么是错误>#</a></h2><p>在写代码时，不是所有情况都能处理，对于不能处理的逻辑，就需要使用错误机制告诉上层调用者。</p><p>在 Go 语言中，错误是被作为一个接口类型对待，它不像其它语言一样使用 <code>try/catch</code> 去捕捉，只需在函数或方法之间使用一个错误类型变量去传递。</p><h2 id=创建错误>创建错误<a hidden class=anchor aria-hidden=true href=#创建错误>#</a></h2><p>这里所说的创建错误，实际上就是去实现错误接口，接口如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>error</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>该接口是 Go 标准包内置的，所有创建的错误类型都需要实现此接口，怎么去实现接口，不懂的看看上篇文章 <a href=/golang-interface/>Golang接口</a>。</p><h3 id=1-errorsnew>1. errors.New<a hidden class=anchor aria-hidden=true href=#1-errorsnew>#</a></h3><p>Go 语言中内置了一个处理错误的标准包，你不需要自己去实现 <code>error</code> 接口，它有函数帮你处理，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;errors&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ErrNotFound</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;not found&#34;</span>)  
</span></span></code></pre></div><p>导入 <code>errors</code> 包，调用 <code>New</code> 函数创建了一个错误并保存到 <code>ErrNotFound</code> 变量，该错误信息为 <code>not found</code> 。</p><h3 id=2-fmterrorf>2. fmt.Errorf<a hidden class=anchor aria-hidden=true href=#2-fmterrorf>#</a></h3><p><code>fmt</code> 标准包内也有一个创建错误的函数 <code>Errorf</code> ，该函数可以使用占位符设置错误信息，比 <code>errors.New</code> 函数更灵活。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ErrHuman</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%s不符合我们人类要求&#34;</span>, <span style=color:#e6db74>&#34;老苗&#34;</span>)  
</span></span></code></pre></div><h3 id=3-自定义错误类型>3. 自定义错误类型<a hidden class=anchor aria-hidden=true href=#3-自定义错误类型>#</a></h3><p>如果上述两种方式你觉得还不够灵活，那可以自定义错误类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ErrorPathNotExist</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>Filename</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ErrorPathNotExist</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;文件路径不存在&#34;</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ErrNotExist</span> <span style=color:#66d9ef>error</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ErrorPathNotExist</span>{  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>Filename</span>: <span style=color:#e6db74>&#34;./main.go&#34;</span>,  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li>自定义了一个 <code>ErrorPathNotExist</code> 结构体，该结构体实现了 <code>error</code> 接口。</li><li>创建了一个 <code>ErrNotExist</code> 错误类型变量。</li></ul><p>这种如果不明白具体怎么应用，不着急，往下看。</p><blockquote><p>补充知识点：如果方法的接收者没有被使用可以直接省略掉，例：<code>func (*ErrorPathNotExist)</code> ，不省略的话就是这样：<code>func (e *ErrorPathNotExist)</code> ，当然也可以使用下划线 "<code>_</code>" 代替 "e" 只是没有必要性。</p></blockquote><h2 id=打印错误>打印错误<a hidden class=anchor aria-hidden=true href=#打印错误>#</a></h2><p>在项目开发中，错误常常通过函数或方法的返回值携带，返回的位置也通常被放置在最后一位。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// error/file.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;io/ioutil&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 读取文件内容  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadConfig</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;./config.json&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>filename</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>content</span> <span style=color:#f92672>:=</span> string(<span style=color:#a6e22e>b</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>content</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;内容为空&#34;</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>content</span>, <span style=color:#66d9ef>nil</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li><code>ReadFile</code> 函数读取 "config.json" 文件内容。</li><li><code>(string, error)</code> 返回两个值，第一个为文件内容，第二个为错误。</li><li><code>err != nil</code> 用于判断是否有错误，如果有 <code>return</code> 直接返回。</li><li><code>string(b)</code> 变量 b 的类型为 <code>[]byte</code> ，该操作是将 <code>[]byte</code> 类型转为 <code>string</code> 。</li><li>增加了一个“内容为空”的错误判断，该错误也可以直接保存到变量中返回。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ErrEmpty</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;内容为空&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadConfig</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span><span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>ErrEmpty</span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p>现在假设 "config.json" 文件不存在，调用 <code>LoadConfig</code> 函数看看结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>    
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#e6db74>&#34;log&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadConfig</span>()  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;内容：&#34;</span>, <span style=color:#a6e22e>content</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>09</span><span style=color:#f92672>/</span><span style=color:#ae81ff>23</span> <span style=color:#ae81ff>16</span>:<span style=color:#ae81ff>57</span>:<span style=color:#ae81ff>25</span> <span style=color:#a6e22e>open</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>json</span>: <span style=color:#a6e22e>The</span> <span style=color:#a6e22e>system</span> <span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>find</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>file</span> <span style=color:#a6e22e>specified</span>.  
</span></span></code></pre></div><ul><li>当 <code>err</code> 不等于 <code>nil</code> 时，打印错误，并退出程序。</li><li><code>log</code> 标准包包含打印日志的函数集。</li><li><code>log.Fatal</code> 函数打印日志，并终止程序向下执行。</li><li>输出的错误消息显示没有找到指定的文件。</li><li>打印错误时，也可以使用 <code>fmt</code> 包，例如：<code>fmt.Println(err)</code> ，只是输出信息没 <code>log</code> 包多。</li></ul><h3 id=osexit>os.Exit<a hidden class=anchor aria-hidden=true href=#osexit>#</a></h3><p>该函数通知程序退出，并且该函数之后的逻辑将不会被执行。在调用时需要指定退出码，为 0 时，表示正常退出程序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>0</span>)  
</span></span></code></pre></div><p>不主动调用该函数，即程序从 main 函数自然结束时，默认的退出码为 0。在使用编写工具时或许能看到成功的退出码信息，例如我使用的是 Goland，执行代码后输出的结果末尾会显示如下信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Process</span> <span style=color:#a6e22e>finished</span> <span style=color:#a6e22e>with</span> <span style=color:#a6e22e>exit</span> <span style=color:#a6e22e>code</span> <span style=color:#ae81ff>0</span>  
</span></span></code></pre></div><p>如果不正常退出，退出码则为非 0，通常使用 1 表示未知错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)  
</span></span></code></pre></div><p>在使用 <code>log.Fatal</code> 函数时，内部就调用了 <code>os.Exit(1)</code> 。</p><h2 id=错误加工>错误加工<a hidden class=anchor aria-hidden=true href=#错误加工>#</a></h2><h3 id=1-错误拼接>1. 错误拼接<a hidden class=anchor aria-hidden=true href=#1-错误拼接>#</a></h3><p>在返回错误时，如果想携带附加的错误消息时，可以使用 <code>fmt.Errorf</code> ，现在修改 <code>LoadConfig</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadConfig</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;./config.json&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>filename</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;读取文件出错:%v&#34;</span>, <span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p><code>%v</code> 占位符表示获取数据的值，在这块表示错误消息，后续会详细讲解占位符的使用。</p><p>现在重新执行上面的 <code>main</code> 函数，还是假设 "config.json" 文件不存在。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadConfig</span>()  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>//...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>09</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> <span style=color:#ae81ff>11</span>:<span style=color:#ae81ff>37</span>:<span style=color:#ae81ff>33</span> <span style=color:#960050;background-color:#1e0010>读取文件出错</span>:<span style=color:#a6e22e>open</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>json</span>: <span style=color:#a6e22e>The</span> <span style=color:#a6e22e>system</span> <span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>find</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>file</span> <span style=color:#a6e22e>specified</span>.  
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p><code>LoadConfig</code> 函数返回的 <code>err</code> 变量中携带了附加的错误消息，但这样有个问题，附加的错误和原始错误消息杂糅在一块导致不能分离。</p><h3 id=2-错误嵌套和-errorsunwrap>2. 错误嵌套和 errors.Unwrap<a hidden class=anchor aria-hidden=true href=#2-错误嵌套和-errorsunwrap>#</a></h3><p>上面所说的”错误消息杂糅在一块导致不能分离“问题，如果还没有明白的话，可以再看看这块，你应该就豁然开朗了。</p><p><img loading=lazy src=/images/56d4dccc2da892ead4b4b474daa57ad9.webp alt=56d4dccc2da892ead4b4b474daa57ad9.webp><br>错误嵌套就类似上图，<code>err1</code> 嵌套类 <code>err2</code> ，<code>err2</code> 也可以继续嵌套。如果想从 <code>err1</code> 中获取 <code>err2</code> 就剥一层，类似洋葱一样，一层一层往里找。</p><p>那怎么实现这种嵌套关系呢，还是使用 <code>fmt.Errorf</code> 函数，只是使用另外一个占位符 <code>%w</code> ，<code>w</code> 的英文全名就是 <code>wrap</code> 。</p><p>继续修改 <code>LoadConfig</code> 函数，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadConfig</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;./config.json&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>filename</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;读取文件出错:%w&#34;</span>, <span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p>现在再执行 <code>main</code> 函数，即调用 <code>LoadConfig</code> 该函数，并打印错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>2021/09/24 18:07:14 读取文件出错:open ./config.json: The system cannot find the file specified.  
</span></span></code></pre></div><p>是不是发现错误结果没有变化，那修改下 <code>main</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#e6db74>&#34;errors&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#e6db74>&#34;log&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadConfig</span>()  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Unwrap</span>(<span style=color:#a6e22e>err</span>))  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span>}  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;内容：&#34;</span>, <span style=color:#a6e22e>content</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>09</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> <span style=color:#ae81ff>18</span>:<span style=color:#ae81ff>11</span>:<span style=color:#ae81ff>09</span> <span style=color:#a6e22e>open</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>json</span>: <span style=color:#a6e22e>The</span> <span style=color:#a6e22e>system</span> <span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>find</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>file</span> <span style=color:#a6e22e>specified</span>.  
</span></span></code></pre></div><p>在打印错误时，增加了一个 <code>errors.Unwrap</code> 函数，该函数就是用来取出嵌套的错误，再看看输出的结果，附加的错误信息”读取文件出错:“已经没有了。</p><h3 id=3-自定义错误类型-1>3. 自定义错误类型<a hidden class=anchor aria-hidden=true href=#3-自定义错误类型-1>#</a></h3><p>在上面讲过了如何自定义错误类型，现在讲讲如何应用你自定义的错误，接下来将 <code>LoadConfig</code> 函数中的内容为空的错误改为自定义错误类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadConfig</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;./config.json&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span>   <span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>content</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>FileEmptyError</span>{  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>Filename</span>: <span style=color:#a6e22e>filename</span>,  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>Err</span>: <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;内容为空&#34;</span>),  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>content</span>, <span style=color:#66d9ef>nil</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p><code>FileEmptyError</code> 是自定义的错误类型，同样的实现 <code>error</code> 接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FileEmptyError</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>Filename</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>Err</span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FileEmptyError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s %v&#34;</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Filename</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Err</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>现在调用 <code>LoadConfig</code> 函数，现在假设 "config.json" 文件存在，但内容为空，结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadConfig</span>()  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>FileEmptyError</span>); <span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Filename:&#34;</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Filename</span>)  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> }  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Filename</span>: .<span style=color:#f92672>/</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>json</span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>09</span><span style=color:#f92672>/</span><span style=color:#ae81ff>27</span> <span style=color:#ae81ff>14</span>:<span style=color:#ae81ff>36</span>:<span style=color:#ae81ff>40</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>json</span> <span style=color:#960050;background-color:#1e0010>内容为空</span>  
</span></span></code></pre></div><ul><li>将 <code>err</code> 变量的接口类型推断为 <code>*FileEmptyError</code> 类型，并输出 <code>Filename</code> 字段。</li><li>打印自定义错误内容。<br>如果想使用 <code>errors.Unwrap</code> 函数 , 就需要实现 <code>Wrapper</code> 接口，<code>fmt.Errorf</code> 函数中的 <code>%w</code> 占位符底层实现好了此接口。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Wrapper</span> <span style=color:#66d9ef>interface</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#75715e>// Unwrap returns the next error in the error chain.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#75715e>// If there is no next error, Unwrap returns nil.  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span><span style=color:#a6e22e>Unwrap</span>() <span style=color:#66d9ef>error</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>只需要我们实现了 <code>Unwrap</code> 方法就可以。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FileEmptyError</span>) <span style=color:#a6e22e>Unwrap</span>() <span style=color:#66d9ef>error</span> {  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Err</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>下来自行去实验，我在这就不罗嗦了。</p><h2 id=错误判断>错误判断<a hidden class=anchor aria-hidden=true href=#错误判断>#</a></h2><p>对于一个函数或方法，返回的错误常常不止一个错误结果，如果对于不同的错误结果你想有不同的处理逻辑，那这个时候就要对错误结果进行判断。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> (  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ErrNotFoundRequest</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;404&#34;</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ErrBadRequest</span>      = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;请求异常&#34;</span>)  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetError</span>() <span style=color:#66d9ef>error</span> {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 错误 1  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrNotFoundRequest</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 错误 2  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrBadRequest</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 错误 3  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>path</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;https://printlove.com&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%s:%w&#34;</span>, <span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>ErrNotFoundRequest</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p><code>GetError</code> 函数没有写具体逻辑，只展示了 3 个错误的返回，下来看看如何对这几种情况进行判断。</p><h3 id=1-最简单->1. 最简单 "<code>==</code>"<a hidden class=anchor aria-hidden=true href=#1-最简单->#</a></h3><p>最简单的就是使用”<code>==</code>“判断错误结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetError</span>()  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ErrNotFoundRequest</span> {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 错误 1  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ErrBadRequest</span> {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 错误 2  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p>对于这种判断方式有个问题，“错误 3" 是不符合这两个 <code>if</code> 判断的，但从错误分类上说，它属于 <code>ErrNotFoundRequest</code> 错误，只是拼接了请求地址数据 <code>path</code> ，下来往下看另外一种判断方式。</p><h3 id=2-errorsis>2. errors.Is<a hidden class=anchor aria-hidden=true href=#2-errorsis>#</a></h3><p>使用 <code>errors.Is</code> 函数解决“错误 3”的判断问题，下来分析为什么？</p><p>“错误 3”中使用了占位符 <code>%w</code>，它就是将  <code>ErrNotFoundRequest</code> 错误嵌入其中，<code>**Is</code> 函数的作用就是一层层的对错误进行剥离判断**，直到成功或没有嵌套的错误为止，没明白的话可以结合上面的图。</p><p>函数定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>bool</span>  
</span></span></code></pre></div><ul><li><code>err</code> 参数为要判断的错误。</li><li><code>target</code> 参数为要比对的错误对象。<br>使用如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetError</span>()  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>ErrNotFoundRequest</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 错误 1,错误3  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>ErrBadRequest</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 错误 2  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><ul><li>在具体项目中，调用函数或方法时，我们不知道底层是否进行了错误嵌套，如果不明确的话就统一使用 <code>Is</code> 函数。</li><li><code>错误 1</code> 和 <code>错误 2</code> 没有嵌套也可以判断。</li></ul><h3 id=3-errorsas>3. errors.As<a hidden class=anchor aria-hidden=true href=#3-errorsas>#</a></h3><p>这个和 <code>errors.Is</code> 函数类似，不同点就是该函数只判断错误类型，而 <code>errors.Is</code> 函数不仅判断类型，也要判断值（错误消息）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// error/as.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ErrorString</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ErrorString</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>s</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>targetErr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ErrorString</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;new error:[%w]&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ErrorString</span>{<span style=color:#a6e22e>s</span>: <span style=color:#e6db74>&#34;target err&#34;</span>})  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>As</span>(<span style=color:#a6e22e>err</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>targetErr</span>))  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>true</span>  
</span></span></code></pre></div><p><code>targetErr</code> 变量有几点要求：</p><ul><li>无需初始化。</li><li>必须是指针类型，并且实现了 <code>error</code> 接口。</li><li><code>As</code> 函数不接受 <code>nil</code> ，因此不能直接使用 <code>targetErr</code> 变量，要使用其引用 <code>&amp;targetErr</code>。</li></ul><h2 id=什么是异常>什么是异常<a hidden class=anchor aria-hidden=true href=#什么是异常>#</a></h2><p>错误就是上述所讲的，它的出现不会导致程序异常退出。<br>那什么情况会异常退出呢？比如：</p><ul><li>下标越界</li><li>除数为 0</li><li>等等</li></ul><p>通常该异常是你没留意到代码问题而抛出，当然你可以可以主动抛出。</p><h2 id=panic>panic<a hidden class=anchor aria-hidden=true href=#panic>#</a></h2><p>使用 <code>panic</code> 函数可以主动抛出异常，该函数格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> panic(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{})  
</span></span></code></pre></div><ul><li><code>v</code> 参数为空接口类型，那就说明可以接受任意类型数据。</li></ul><p>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>panic(<span style=color:#e6db74>&#34;我是异常&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>panic</span>: <span style=color:#960050;background-color:#1e0010>我是异常</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:  
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>C</span>:<span style=color:#f92672>/</span><span style=color:#a6e22e>workspace</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>gobasic</span><span style=color:#f92672>/</span><span style=color:#a6e22e>panic</span><span style=color:#f92672>/</span><span style=color:#a6e22e>panic</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x45</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>exit</span> <span style=color:#a6e22e>status</span> <span style=color:#ae81ff>2</span>  
</span></span></code></pre></div><p>从输出的结果上可以看出几点：</p><ul><li>打印出具体的异常位置，这些信息称作堆栈信息。</li><li>程序终止，退出码为 2。</li></ul><h2 id=处理异常>处理异常<a hidden class=anchor aria-hidden=true href=#处理异常>#</a></h2><p>不管是主动抛出异常，还是你程序哪块有 bug 被动抛出异常，这些在我们写项目时都是很严重的问题，因为它会导致我们的程序异常退出。</p><p>在其它语言中，通过 <code>try/catch</code> 机制可以捕捉异常来保证程序的正常运行，那在 Go 语言中使用 <code>recover</code> 函数捕捉异常。</p><p>在学习这个函数前，先要了解另外一个关键字 <code>defer</code> 。</p><h3 id=1-defer>1. defer<a hidden class=anchor aria-hidden=true href=#1-defer>#</a></h3><p>它不是函数，只是一个关键字。该关键字后面所跟的语句将延迟执行，在所在函数或方法正常结束时或出现异常中断时，再提前执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer&#34;</span>)  
</span></span><span style=display:flex><span>	}()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;panic&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>panic</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>  
</span></span></code></pre></div><ul><li><code>defer</code> 关键字后面跟了一个匿名函数调用，有名字的函数当然也可以。</li><li>遇到 <code>defer</code> 关键字，后面的语句会延迟执行，因此先输出 "main" 字符串。</li><li><code>panic</code> 抛出异常，因此在退出前先执行 <code>defer</code> 语句。</li><li>如果调用了 <code>os.Exit</code> 函数，<code>defer</code> 后的语句将不会执行。</li></ul><p>如果在一个函数或方法中出现了<strong>多个 <code>defer</code> 语句，那会采用先进后出原则</strong>，即先出现的 <code>defer</code> 语句后执行，后出现的先执行。</p><p>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;猜我啥时候输出？&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer&#34;</span>)  
</span></span><span style=display:flex><span>	}()  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>Fun1</span>()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;panic&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>猜我啥时候输出？</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>panic</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>  
</span></span></code></pre></div><p>现在讲了 <code>defer</code> 关键字的概念，可能还不知道实际中什么地方用到，我现在举个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// defer/main.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 拷贝文件  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// srcName 路径文件拷贝到 dstName 路径文件   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CopyFile</span>(<span style=color:#a6e22e>srcName</span>, <span style=color:#a6e22e>dstName</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>written</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>srcName</span>)  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>Close</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>dstName</span>)  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>Close</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Copy</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>代码中有两个 <code>defer</code> 关键字，后面的语句用来关闭文件释放资源。</p><p>如果不用此关键字，关闭文件的 <code>Close</code> 函数就必须写在 <code>io.Copy</code> 函数后，因为该函数还要使用文件资源，提前关闭了，就完蛋了。所以，使用 <code>defer</code> 关键字后就会延迟执行，因此就不需要考虑文件什么时候被使用。</p><p>当然也不是只有这一种情况应用，只要记住，在函数或方法结束前你才想处理的语句都可以使用 <code>defer</code> 关键字。</p><h3 id=2-recover>2. recover<a hidden class=anchor aria-hidden=true href=#2-recover>#</a></h3><p>了解了 <code>defer</code> 关键字后就明白了，在程序出现异常之前 <code>defer</code> 语句先被执行，因此在 <code>defer</code> 后的语句就可以提前拦截异常。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// panic/recover.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;我捕捉的：&#34;</span>, <span style=color:#a6e22e>err</span>)  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;我好好的&#34;</span>)  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>	}()  
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;我是异常&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>我捕捉的：</span> <span style=color:#960050;background-color:#1e0010>我是异常</span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>我好好的</span>  
</span></span></code></pre></div><ul><li><code>recover</code> 返回异常信息。</li></ul><p>不管是主动抛出异常，还是被动的，<code>recover</code> 函数都能捕捉，这样以保证程序的正常进行。</p><p>假如函数 <code>A</code> 调用了很多函数，这些函数又调用了很多，只要下面被调用的函数出现异常，函数 <code>A</code> 中的 <code>recover</code> 函数将都可以捕捉到。但其中还是有个特例， <code>Goroutine</code> 中出现的异常是无法被捕捉到的，必须在新的 <code>Goroutine</code> 中重新使用 <code>recover</code> 函数，这个让人期待的知识点后续会讲。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本篇讲解了两个概念，”错误“和”异常“ ，这两个概念很重要，一定要掌握明白。还有一点，在处理错误时，有时候发觉错误结果对于我们没用，那这个时候就可以忽略掉。</p><p>我写的时候也想尽可能的讲明白，有些地方就会啰嗦些。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.printlove.cn/tags/program_golang/>program_golang</a></li></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/golang-format/><span class=title>« 上一页</span><br><span>Go基础系列：17. 详解 20 个占位符</span></a>
<a class=next href=https://www.printlove.cn/golang-interface/><span class=title>下一页 »</span><br><span>Go基础系列：15. 接口</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：16. 错误与异常 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a16.%20%e9%94%99%e8%af%af%e4%b8%8e%e5%bc%82%e5%b8%b8&amp;url=https%3a%2f%2fwww.printlove.cn%2fgolang-error%2f&amp;hashtags=program_golang"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：16. 错误与异常 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a16.%20%e9%94%99%e8%af%af%e4%b8%8e%e5%bc%82%e5%b8%b8"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>