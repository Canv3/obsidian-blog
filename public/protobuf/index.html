<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入微服务：3. Protobuf 为啥比 JSON、XML 牛？ | PrintLove</title><meta name=keywords content="Protobuf"><meta name=description content="Protobuf 的实现原理，并说明 JSON、XML 的不同支持"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/protobuf/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="深入微服务：3. Protobuf 为啥比 JSON、XML 牛？"><meta property="og:description" content="Protobuf 的实现原理，并说明 JSON、XML 的不同支持"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/protobuf/"><meta property="og:image" content="https://imgs-go-instagram.insloves.com/images/v2-0e6f115b88d34f8186f766f63603e4fa_r.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-19T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-19T00:00:00+00:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://imgs-go-instagram.insloves.com/images/v2-0e6f115b88d34f8186f766f63603e4fa_r.jpg"><meta name=twitter:title content="深入微服务：3. Protobuf 为啥比 JSON、XML 牛？"><meta name=twitter:description content="Protobuf 的实现原理，并说明 JSON、XML 的不同支持"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"深入微服务：3. Protobuf 为啥比 JSON、XML 牛？","item":"https://www.gby.ai/protobuf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入微服务：3. Protobuf 为啥比 JSON、XML 牛？","name":"深入微服务：3. Protobuf 为啥比 JSON、XML 牛？","description":"Protobuf 的实现原理，并说明 JSON、XML 的不同支持","keywords":["Protobuf"],"articleBody":"大家好，我是 “潇洒哥老苗”。\n今天，我带大家更深层次的认识认识 Protobuf，如果你对 Protobuf 的用法还不熟悉，直接前往：https://developers.google.com/protocol-buffers/docs/proto3。\n当对 Protobuf 有了基本的认识后，就会明白了 Protobuf 序列化的数据会比 JSON、XML 传输效率更高。\n那为啥会高呢？本篇就带着这个问题一探究竟。\n看表面 对于 JSON、XML，为了便于数据传输时的可阅读性，会保留数据的结构化信息，举个 JSON 例子，如下：\n{ \"name\": \"laomiao\", \"age\": 18 } 当发送该信息时，接受方收到后就会明白，这是个 “key/value” 形式的数据，并且 \"name\" 后是姓名，\"age\" 后是年龄。\n那如何压缩该数据呢？\n我们可以删除 “花括号”、“name”、“age” 以及其它的 “冒号”、“逗号”、“引号” 等结构数据。\nlaomiao18 那这样删除了，接收方怎么知道，哪个是姓名？哪个是年龄？\n删除 ”结构“ 只需要发送方和接收方都保留这份数据的 ”结构“ 就行，发送方只发送数据，接收方接收到数据后，根据本地保留的 ”结构“ 去解析数据就 OK。\n假设，该 \" 结构 \" 如下，这不是真实存在的，只是为了方便给大家描述。\n{ name string 7 age int 1 } 通过该 ”结构“ 就可以知道：\nname 数据在 age 数据之前。 name 数据类型为 string，age 数据类型为 int。 name 数据字节长度为 7，age 数据字节长度为 1。 接收方只需要拿着这份 ”结构“ 就知道了 \"laomiao18\" 数据如何解析。\n自描述 但这样还是有这些问题：\nname 数据如果超过 7 个字节怎么办？ age 数据超过 1 个字节怎么办？ 结构中的顺序不能调整，太死了，怎么办？ 当然，发送方和接收方都更新下自己的 ”结构“ 数据，但这样显然不现实，因为数据你不能保证是固定长度。\n对于 age 数据，我们可以定义为 4 个字节或 8 个字节，只要可以应对自己的业务即可。但这样还是有问题，空间浪费？\n假如，age 定义为 4 个字节，传输的数据为 18，而对于 18 这个数字，只需要 1 个字节就足以了，而剩下 3 个字节都浪费着。但咱又不能定义为 1 个字节，因为有可能会有大数。\n那如何压缩 age 数据呢？\n对于 Protobuf，会在数据中加入解决以上问题的信息，即数据自己描述自己，简称 ”自描述“。\n总结下 Protobuf 做了哪些？如下：\n数据中加入 ”字段“ 顺序的信息。 数据中加入类型信息。 最小化压缩整形数据。 Protobuf Protobuf 在序列化数据时，将 Protobuf 数据类型总共划分为 6 大类，英文称为 \"wire type\"。\nwire type proto 类型 含义 0 int32, int64, uint32, uint64, sint32, sint64, bool, enum Varint 1 fixed64, sfixed64, double 64-bit 2 string, bytes, embedded messages, packed repeated fields Length-delimited 3 groups (废弃) Start group 4 groups (废弃) End group 5 fixed32, sfixed32, float 32-bit \"wire type\" 中的 ”3“ 和 ”4“ 类型已废弃，这块不做讲解。\n下来通过一个 message 信息展开说明，如下：\nmessage HelloRequest { string name = 1; int32 num = 2; float height = 3; repeated int32 hobbies= 4; } 这就好比我上面所说的 ”结构“，发送方和接收方就是通过该结构去解析数据。现在我们就针对上面留下的问题一一说明。\n1. 类型和顺序 那传输的数据中如何保存 ”数据类型“ 和 ”顺序“？\n数据类型对应到 \"wire type\"，顺序对应到 ”field number“。假如 int32 num = 2 对应如下：\nwire type：0，通过上面表格对应。 field number：2，字段后的唯一编码。 将这两个信息按照如下公式组装：\n(field_number \u003c\u003c 3) | wire_type 带入得：\n(2 \u003c\u003c 3) | 0 → 16 2. Varint 对于 num 字段保存的数据如何如何压缩？假如 num 存储的数据为 300。按照 4 字节存储如下：\n00000000 00000000 00000001 00101100 从结果可以看到，真实有效的数据只有 2 字节，为了压缩，面对不同的数据大小会占用不用的字节数。\n那如何记录数据长度？我们可以再增加一个字节去记录真实数据所占用的实际字节数。对于 300 数据，增加一个字节记录长度，那下来和数据一块总共需要 3 个字节。那还有什么办法再减少字节数吗？\n当然会有呀，不然我就说了一堆废话，咱继续。\n请出 Varint 算法，过程如下：\n将数据以 7 位为一组进行分割； 将组的顺序颠倒，即：将 ”高位 → 低位“ 规则，改为 ”低位 → 高位“； 识别每一组，如果该组后还有数据，就在该组前增加一位 ”1”，否则增加 “0”。 将数据 300 带入该算法，过程如下：\n300: 00000000 00000000 00000001 00101100 → 7 位分割：0000 0000000 0000000 0000010 0101100 → 颠倒顺序：0101100 0000010 0000000 0000 → 组前加 1/0：10101100 00000010 → 十进制：172 2 按照这套算法下来，将数据压缩为 2 个字节存储。而接收方拿到字节数据后，只需要按照高位识别，如果为 0，说明之后没有数据了。\n最终，对于 int32 num = 2 结构和数据 300，压缩后的结果为：\n16 172 2 3. Length-delimited 现在说说 string name = 1 ，该类型对应的 \"wire type\" 为 2，\"field number\" 为 1。记录 “顺序” 和 “类型” 方式和上面讲的一样。\n重点说说数据如何记录，相比 Varint 算法，该类型就简单多了，只需要使用 Varint 算法记录数据的字节长度。\n假如，name 的值为 \"miao\"，最终结果为：\n10 4 109 105 97 111 解释：\n10：(1 \u003c\u003c 3) | 2 。 4：字符串长度。 之后：按照 \"UTF-8\" 编码保存。 对于 message 嵌套、repeated (数组或切片)、字节数组，也是按照该算法得到。\n例如，repeated int32 hobbies= 4 ，假设 hobbies 数据为 [10, 20]，最终结果为：\n34 2 10 20 4. 浮点数 针对浮点类型，就更简单了，浮点数据使用固定字节保存，记录 “顺序” 和 “类型” 依然是上面讲的。\n假如，float height = 3 ，该类型对应的 \"wire type\" 为 5，数据假设为 52.1，最终结果为：\n29 102 102 80 66 解释：\n29：(3 \u003c\u003c 3) | 5 。 之后：使用固定字节数 4。 如果使用了双精度，那对应的 \"wire type\" 为 1，数据占用字节数为 8。\n5. sint32/sint64 这两个类型不知道你在写 proto 文件时有没有用到，明白这个很重要，不然有时候数据就不能起被到压缩的作用。\n上面讲到的 Varint 算法中，我们知道了以 7 位一组，再增加一位 “识别位” 来起到压缩数据的作用。但存在一个问题，倘若存在负数时，那这种压缩方式就失效了。\n至于为啥？如何解决的？\n我先说结果，如果写 proto 文件时，设置的数据类型为 sint32 或 sint64 时，将采用 ZigZag 算法进行数据压缩。\nZigZag 算法我就不重复讲解了，直接看 上一篇。\n小结 学完本篇我们知道了 Protobuf 怎么做到了压缩数据。简单说下，就是删除一些没用的信息，采用自描述的方式记录 “类型”、“顺序”、“数据”。\n而对于类型，只记录了 \"wire type\"，该类型确定了数据的大概处理方式。\n那说它就一定比 JSON、XML 好吗？也不是。\n因为要采用 Protobuf 方式传输数据，发送放和接收方必须采用同一套结构规则，也可以说 “协议”。所以，如果想提高数据的阅读性，降低这种规则的配合，就可以使用 JSON、XML。\n后面我会使用 Go 语言实现 Protobuf 序列化和反序列化的核心算法，只要这样我才觉得真的明白了该算法的真谛。\n可持续关注该项目：https://github.com/miaogaolin/gofirst，该 系列 的所有代码往后都会加入进去。\n参考 官网算法讲解：https://developers.google.com/protocol-buffers/docs/encoding ","wordCount":"479","inLanguage":"zh","image":"https://imgs-go-instagram.insloves.com/images/v2-0e6f115b88d34f8186f766f63603e4fa_r.jpg","datePublished":"2021-11-19T00:00:00Z","dateModified":"2021-11-19T00:00:00Z","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/protobuf/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>深入微服务：3. Protobuf 为啥比 JSON、XML 牛？</h1><div class=post-meta><span title='2021-11-19 00:00:00 +0000 UTC'>2021-11-19</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/%e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a3.%20Protobuf%20%e4%b8%ba%e5%95%a5%e6%af%94%20JSON%e3%80%81XML%20%e7%89%9b.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#看表面>看表面</a><ul><li><a href=#删除-结构>删除 ”结构“</a></li><li><a href=#自描述>自描述</a></li></ul></li><li><a href=#protobuf>Protobuf</a><ul><li><a href=#1-类型和顺序>1. 类型和顺序</a></li><li><a href=#2-varint>2. Varint</a></li><li><a href=#3-length-delimited>3. Length-delimited</a></li><li><a href=#4-浮点数>4. 浮点数</a></li><li><a href=#5-sint32sint64>5. sint32/sint64</a></li></ul></li><li><a href=#小结>小结</a></li><li><a href=#参考>参考</a></li></ul></nav></div></details></div><div class=post-content><p>大家好，我是 “潇洒哥老苗”。</p><p>今天，我带大家更深层次的认识认识 Protobuf，如果你对 Protobuf 的用法还不熟悉，直接前往：<a href=https://developers.google.com/protocol-buffers/docs/proto3>https://developers.google.com/protocol-buffers/docs/proto3</a>。</p><p>当对 Protobuf 有了基本的认识后，就会明白了 Protobuf 序列化的数据会比 JSON、XML 传输效率更高。</p><p>那为啥会高呢？本篇就带着这个问题一探究竟。</p><h2 id=看表面>看表面<a hidden class=anchor aria-hidden=true href=#看表面>#</a></h2><p>对于 JSON、XML，为了便于数据传输时的可阅读性，会保留数据的结构化信息，举个 JSON 例子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{  
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;laomiao&#34;</span>,  
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;age&#34;</span>: <span style=color:#ae81ff>18</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>当发送该信息时，接受方收到后就会明白，这是个 “key/value” 形式的数据，并且 "name" 后是姓名，"age" 后是年龄。</p><p>那如何压缩该数据呢？</p><p>我们可以删除 “花括号”、“name”、“age” 以及其它的 “冒号”、“逗号”、“引号” 等结构数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>laomiao18  
</span></span></code></pre></div><p>那这样删除了，接收方怎么知道，哪个是姓名？哪个是年龄？</p><h3 id=删除-结构>删除 ”结构“<a hidden class=anchor aria-hidden=true href=#删除-结构>#</a></h3><p>只需要发送方和接收方都保留这份数据的 ”结构“ 就行，发送方只发送数据，接收方接收到数据后，根据本地保留的 ”结构“ 去解析数据就 OK。</p><p>假设，该 " 结构 " 如下，这不是真实存在的，只是为了方便给大家描述。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>{  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span> <span style=color:#ae81ff>7</span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>通过该 ”结构“ 就可以知道：</p><ul><li>name 数据在 age 数据之前。</li><li>name 数据类型为 string，age 数据类型为 int。</li><li>name 数据字节长度为 7，age 数据字节长度为 1。</li></ul><p>接收方只需要拿着这份 ”结构“ 就知道了 "laomiao18" 数据如何解析。</p><h3 id=自描述>自描述<a hidden class=anchor aria-hidden=true href=#自描述>#</a></h3><p>但这样还是有这些问题：</p><ol><li>name 数据如果超过 7 个字节怎么办？</li><li>age 数据超过 1 个字节怎么办？</li><li>结构中的顺序不能调整，太死了，怎么办？</li></ol><p>当然，发送方和接收方都更新下自己的 ”结构“ 数据，但这样显然不现实，因为数据你不能保证是固定长度。</p><p>对于 age 数据，我们可以定义为 4 个字节或 8 个字节，只要可以应对自己的业务即可。但这样还是有问题，空间浪费？</p><p>假如，age 定义为 4 个字节，传输的数据为 18，而对于 18 这个数字，只需要 1 个字节就足以了，而剩下 3 个字节都浪费着。但咱又不能定义为 1 个字节，因为有可能会有大数。</p><p>那如何压缩 age 数据呢？</p><p>对于 Protobuf，会在数据中加入解决以上问题的信息，即数据自己描述自己，简称 ”自描述“。</p><p>总结下 Protobuf 做了哪些？如下：</p><ul><li>数据中加入 ”字段“ 顺序的信息。</li><li>数据中加入类型信息。</li><li>最小化压缩整形数据。</li></ul><h2 id=protobuf>Protobuf<a hidden class=anchor aria-hidden=true href=#protobuf>#</a></h2><p>Protobuf 在序列化数据时，将 Protobuf 数据类型总共划分为 6 大类，英文称为 "wire type"。</p><table><thead><tr><th>wire type</th><th>proto 类型</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td><td>Varint</td></tr><tr><td>1</td><td>fixed64, sfixed64, double</td><td>64-bit</td></tr><tr><td>2</td><td>string, bytes, embedded messages, packed repeated fields</td><td>Length-delimited</td></tr><tr><td>3</td><td>groups (废弃)</td><td>Start group</td></tr><tr><td>4</td><td>groups (废弃)</td><td>End group</td></tr><tr><td>5</td><td>fixed32, sfixed32, float</td><td>32-bit</td></tr></tbody></table><p>"wire type" 中的 ”3“ 和 ”4“ 类型已废弃，这块不做讲解。</p><p>下来通过一个 message 信息展开说明，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloRequest</span> {  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>float</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>int32</span> hobbies<span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}  <span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>这就好比我上面所说的 ”结构“，发送方和接收方就是通过该结构去解析数据。现在我们就针对上面留下的问题一一说明。</p><h3 id=1-类型和顺序>1. 类型和顺序<a hidden class=anchor aria-hidden=true href=#1-类型和顺序>#</a></h3><p>那传输的数据中如何保存 ”数据类型“ 和 ”顺序“？</p><p>数据类型对应到 "wire type"，顺序对应到 ”field number“。假如 <code>int32 num = 2</code> 对应如下：</p><ul><li>wire type：0，通过上面表格对应。</li><li>field number：2，字段后的唯一编码。</li></ul><p>将这两个信息按照如下公式组装：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>(field_number &lt;&lt; 3) | wire_type  
</span></span></code></pre></div><p>带入得：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>(2 &lt;&lt; 3) | 0   
</span></span><span style=display:flex><span>→ 16  
</span></span></code></pre></div><h3 id=2-varint>2. Varint<a hidden class=anchor aria-hidden=true href=#2-varint>#</a></h3><p>对于 num 字段保存的数据如何如何压缩？假如 num 存储的数据为 300。按照 4 字节存储如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>00000000 00000000 00000001 00101100  
</span></span></code></pre></div><p>从结果可以看到，真实有效的数据只有 2 字节，为了压缩，面对不同的数据大小会占用不用的字节数。</p><p>那如何记录数据长度？我们可以再增加一个字节去记录真实数据所占用的实际字节数。对于 300 数据，增加一个字节记录长度，那下来和数据一块总共需要 3 个字节。那还有什么办法再减少字节数吗？</p><p>当然会有呀，不然我就说了一堆废话，咱继续。</p><p>请出 Varint 算法，过程如下：</p><ul><li>将数据以 7 位为一组进行分割；</li><li>将组的顺序颠倒，即：将 ”高位 → 低位“ 规则，改为 ”低位 → 高位“；</li><li>识别每一组，如果该组后还有数据，就在该组前增加一位 ”1”，否则增加 “0”。</li></ul><p>将数据 300 带入该算法，过程如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>300: 00000000 00000000 00000001 00101100  
</span></span><span style=display:flex><span>→ 7 位分割：0000 0000000 0000000 0000010 0101100  
</span></span><span style=display:flex><span>→ 颠倒顺序：0101100 0000010 0000000 0000  
</span></span><span style=display:flex><span>→ 组前加 1/0：10101100 00000010  
</span></span><span style=display:flex><span>→ 十进制：172 2  
</span></span></code></pre></div><p>按照这套算法下来，将数据压缩为 2 个字节存储。而接收方拿到字节数据后，只需要按照高位识别，如果为 0，说明之后没有数据了。</p><p>最终，对于 <code>int32 num = 2</code> 结构和数据 300，压缩后的结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>16 172 2  
</span></span></code></pre></div><h3 id=3-length-delimited>3. Length-delimited<a hidden class=anchor aria-hidden=true href=#3-length-delimited>#</a></h3><p>现在说说 <code>string name = 1</code> ，该类型对应的 "wire type" 为 2，"field number" 为 1。记录 “顺序” 和 “类型” 方式和上面讲的一样。</p><p>重点说说数据如何记录，相比 Varint 算法，该类型就简单多了，只需要使用 Varint 算法记录数据的字节长度。</p><p>假如，name 的值为 "miao"，最终结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>10 4 109 105 97 111  
</span></span></code></pre></div><p>解释：</p><ul><li>10：<code>(1 &lt;&lt; 3) | 2</code> 。</li><li>4：字符串长度。</li><li>之后：按照 "UTF-8" 编码保存。</li></ul><p>对于 message 嵌套、repeated (数组或切片)、字节数组，也是按照该算法得到。</p><p>例如，<code>repeated int32 hobbies= 4</code> ，假设 hobbies 数据为 <code>[10, 20]</code>，最终结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>34 2 10 20  
</span></span></code></pre></div><h3 id=4-浮点数>4. 浮点数<a hidden class=anchor aria-hidden=true href=#4-浮点数>#</a></h3><p>针对浮点类型，就更简单了，浮点数据使用固定字节保存，记录 “顺序” 和 “类型” 依然是上面讲的。</p><p>假如，<code>float height = 3</code> ，该类型对应的 "wire type" 为 5，数据假设为 52.1，最终结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>29 102 102 80 66  
</span></span></code></pre></div><p>解释：</p><ul><li>29：<code>(3 &lt;&lt; 3) | 5</code> 。</li><li>之后：使用固定字节数 4。</li></ul><p>如果使用了双精度，那对应的 "wire type" 为 1，数据占用字节数为 8。</p><h3 id=5-sint32sint64>5. sint32/sint64<a hidden class=anchor aria-hidden=true href=#5-sint32sint64>#</a></h3><p>这两个类型不知道你在写 proto 文件时有没有用到，明白这个很重要，不然有时候数据就不能起被到压缩的作用。</p><p>上面讲到的 Varint 算法中，我们知道了以 7 位一组，再增加一位 “识别位” 来起到压缩数据的作用。但存在一个问题，倘若存在负数时，那这种压缩方式就失效了。</p><p>至于为啥？如何解决的？</p><p>我先说结果，如果写 proto 文件时，设置的数据类型为 sint32 或 sint64 时，将采用 ZigZag 算法进行数据压缩。</p><p>ZigZag 算法我就不重复讲解了，直接看 <a href=/posts/ms/zigzag/>上一篇</a>。</p><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>学完本篇我们知道了 Protobuf 怎么做到了压缩数据。简单说下，就是删除一些没用的信息，采用自描述的方式记录 “类型”、“顺序”、“数据”。</p><p>而对于类型，只记录了 "wire type"，该类型确定了数据的大概处理方式。</p><p>那说它就一定比 JSON、XML 好吗？也不是。</p><p>因为要采用 Protobuf 方式传输数据，发送放和接收方必须采用同一套结构规则，也可以说 “协议”。所以，如果想提高数据的阅读性，降低这种规则的配合，就可以使用 JSON、XML。</p><p>后面我会使用 Go 语言实现 Protobuf 序列化和反序列化的核心算法，只要这样我才觉得真的明白了该算法的真谛。</p><p>可持续关注该项目：<a href=https://github.com/miaogaolin/gofirst>https://github.com/miaogaolin/gofirst</a>，该 <a href=/series/go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/>系列</a> 的所有代码往后都会加入进去。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li>官网算法讲解：<a href=https://developers.google.com/protocol-buffers/docs/encoding#simple>https://developers.google.com/protocol-buffers/docs/encoding</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.gby.ai/golang-unit-test/><span class=title>« 上一页</span><br><span>Go基础系列：19. 单元测试</span></a>
<a class=next href=https://www.gby.ai/zigzag/><span class=title>下一页 »</span><br><span>深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 深入微服务：3. Protobuf 为啥比 JSON、XML 牛？ on x" href="https://x.com/intent/tweet/?text=@laomiao_ %e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a3.%20Protobuf%20%e4%b8%ba%e5%95%a5%e6%af%94%20JSON%e3%80%81XML%20%e7%89%9b%ef%bc%9f&amp;url=https%3a%2f%2fwww.gby.ai%2fprotobuf%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入微服务：3. Protobuf 为啥比 JSON、XML 牛？ on email" href="mailto:mglluoye@gmail.com?subject=%e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a3.%20Protobuf%20%e4%b8%ba%e5%95%a5%e6%af%94%20JSON%e3%80%81XML%20%e7%89%9b%ef%bc%9f"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>