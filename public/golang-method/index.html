<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：13. 自定义类型和结构体 - 方法 | PrintLove</title><meta name=keywords content="Go,结构体"><meta name=description content="自定义类型和结构体如何携带方法？什么是值接收者？什么是指针接收者？等等等"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/golang-method/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：13. 自定义类型和结构体 - 方法"><meta property="og:description" content="自定义类型和结构体如何携带方法？什么是值接收者？什么是指针接收者？等等等"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/golang-method/"><meta property="og:image" content="https://images.unsplash.com/photo-1495468710622-4b59f514ca22?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxNHx8bWV0aG9kfGVufDB8MHx8fDE3MDMxNDA0MDV8MA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-10T11:30:56+08:00"><meta property="article:modified_time" content="2021-09-10T11:30:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1495468710622-4b59f514ca22?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxNHx8bWV0aG9kfGVufDB8MHx8fDE3MDMxNDA0MDV8MA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：13. 自定义类型和结构体 - 方法"><meta name=twitter:description content="自定义类型和结构体如何携带方法？什么是值接收者？什么是指针接收者？等等等"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：13. 自定义类型和结构体 - 方法","item":"https://www.gby.ai/golang-method/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：13. 自定义类型和结构体 - 方法","name":"Go基础系列：13. 自定义类型和结构体 - 方法","description":"自定义类型和结构体如何携带方法？什么是值接收者？什么是指针接收者？等等等","keywords":["Go","结构体"],"articleBody":"学到什么 什么是方法？ 如何调用方法？ 什么是值接收者和指针接收者？ 如何使用 new 函数？ 什么是私有方法和公有方法？ 概念 上篇学习了什么是自定义类型，对于结构体也是自定义类型的一种，那方法是什么？\n如果一个函数属于一个自定义类型时，那它被称为方法，类似于面向对象中给类增加方法。\n方法格式 在函数名前面写上自己所属的自定义类型后，这个函数就变为了该类型的方法。\ntype People ... func (p *People) SetName(name string) string { // ... } 第一行自定义了一个类型，名为 People。 p *People 确定了 SetName 函数属于 *People 类型，p 为类型的别名，也称为接收者。p 类似面向对象语言中的 this , People 类似”class 类“。 如果携带方法，自定义的类型不能为接口类型（interface{}）和 指针。 注：*People 前面的“星号”确定了接收者为指针类型，称为指针接收者，下面会讲。\n方法名称 方法的名称在类型的所有方法名称和所有字段名称中必须是唯一的。就算相同的名称一个是字段一个是方法名也是不可以的。\ntype People struct { Name string } func (p People) Name() string { return p.Name } 以上代码错误，名称不唯一。\n如果方法名称和类型名称相同是可以允许的。\n方法调用 不管自定义的类型是基于内置类型还是结构体，都可以携带方法。\n// 内置类型 type Num int func (n Num) String() string { return fmt.Sprintf(\"%d\", n) } // 结构体 type People struct { Name string Age int } func (p People) GetName() string { return p.Name } 以上代码中定义了两个类型，每个类型分别携带了一个方法。\n下来如何调用这两个方法：\nvar n Num n.String() var p Peple p.GetName() 先初始化好类型，然后再用“点”符号调用。\n值接受者和指针接收者 1. 定义 在上面的代码中，是否注意到接收者类型有两种，一种是带星号（*People），一种是不带的（People 和 Num）。\n总结为：\n带星号的称为：指针接收者。\n不带星号的称为：值接收者。\n还有一种特殊情况就是自定义的类型本身就是引用类型，就算接收者类型声明中带不带”星号“它也属于指针接收者。\ntype M map[string]string func (m M) SetKey(key, val string) { (m)[key] = val } 因为 M 类型依赖的是 map 类型，map 本身就是一个引用类型，因此 m 为指针接收者。\n2. 区别 如果方法是值接收者，执行方法时接收者会被拷贝一份，即使方法修改了接收者的值也不是原来的一份。\nfunc (p People) SetName(name string) string { p.Name = name return name } 初始化 People 修改 Name 字段。\np1 := People{Name: \"苗\"} p1.SetName(\"潇洒哥\") fmt.Println(p1.Name) // 输出 苗 发现了没，虽然调用了方法进行了修改，但还是不生效。因为 p1 和接收者 p 已经不是一个值了。如果想修改生效，只需把值接收者改为指针接收者。\nfunc (p *People) SetName(name string) string { p.Name = name return name } 3. 调用时类型转化 在调用方法时，不管是值接收者还是指针接收者，调用时的变量类型是否是指针是不影响的。\n例如：People 结构体的方法 SetName 不管是指针还是值接收者，以下代码都可以调用。\n// 值 p1 := People{} p1.SetName() // 指针 p2 := \u0026People{} p2.SetName() 至于为什么？当编译器发现你调用的变量（ p1 和 p2 ）类型和接收者的类型不相同时，也就是一个是指针一个不是，这个时候就会自动转化。\n至于接收者的值被方法修改时结果会不会改变，和调用变量的类型没关系。\nNew 函数使用 当初始化一个指针变量时，可以使用 \"\u0026\" 符号，也可以使用 new 函数。\nnew(T) 例如，将 p2 := \u0026People{} 修改。\np2 := new(People) p2.Name = \"老苗\" new(People) 和 \u0026People{} 等价。\n私有和公有 方法名大写字母开头公有，小写字母开头私有。如果方法所在的包和调用者不是同一个，那私有方法是不能被调用的，只能调用公有方法。\n私有方法只能在同一个包内被调用。\n总结 本篇文章完了之后，自定义类型和结构体的知识点就讲完了，如果看到了这就给自己点个赞，坚持住！！！\n","wordCount":"247","inLanguage":"zh","image":"https://images.unsplash.com/photo-1495468710622-4b59f514ca22?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxNHx8bWV0aG9kfGVufDB8MHx8fDE3MDMxNDA0MDV8MA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-09-10T11:30:56+08:00","dateModified":"2021-09-10T11:30:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/golang-method/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：13. 自定义类型和结构体 - 方法</h1><div class=post-meta><span title='2021-09-10 11:30:56 +0800 CST'>2021-09-10</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a13.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e6%96%b9%e6%b3%95.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#概念>概念</a></li><li><a href=#方法格式>方法格式</a></li><li><a href=#方法名称>方法名称</a></li><li><a href=#方法调用>方法调用</a></li><li><a href=#值接受者和指针接收者>值接受者和指针接收者</a><ul><li><a href=#1-定义>1. 定义</a></li><li><a href=#2-区别>2. 区别</a></li><li><a href=#3-调用时类型转化>3. 调用时类型转化</a></li></ul></li><li><a href=#new-函数使用>New 函数使用</a></li><li><a href=#私有和公有>私有和公有</a></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>什么是方法？</li><li>如何调用方法？</li><li>什么是值接收者和指针接收者？</li><li>如何使用 new 函数？</li><li>什么是私有方法和公有方法？</li></ol><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><p>上篇学习了什么是自定义类型，对于结构体也是自定义类型的一种，那方法是什么？</p><p>如果一个函数属于一个自定义类型时，那它被称为方法，类似于面向对象中给类增加方法。</p><h2 id=方法格式>方法格式<a hidden class=anchor aria-hidden=true href=#方法格式>#</a></h2><p>在函数名前面写上自己所属的自定义类型后，这个函数就变为了该类型的方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#f92672>...</span>   
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>SetName</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	 <span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><ul><li>第一行自定义了一个类型，名为 <code>People</code>。</li><li><code>p *People</code> 确定了 <code>SetName</code> 函数属于 <code>*People</code> 类型，<code>p</code> 为类型的别名，也称为接收者。<code>p</code> 类似面向对象语言中的 <code>this</code> , <code>People</code> 类似”class 类“。</li><li>如果携带方法，自定义的类型不能为接口类型（<code>interface{}</code>）和 指针。</li></ul><p>注：<code>*People</code> 前面的“星号”确定了接收者为指针类型，称为指针接收者，下面会讲。</p><h2 id=方法名称>方法名称<a hidden class=anchor aria-hidden=true href=#方法名称>#</a></h2><p>方法的名称在类型的所有方法名称和所有字段名称中必须是唯一的。就算相同的名称一个是字段一个是方法名也是不可以的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>以上代码错误，名称不唯一。</p><p>如果方法名称和类型名称相同是可以允许的。</p><h2 id=方法调用>方法调用<a hidden class=anchor aria-hidden=true href=#方法调用>#</a></h2><p>不管自定义的类型是基于内置类型还是结构体，都可以携带方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 内置类型  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Num</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#a6e22e>Num</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#a6e22e>n</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 结构体  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>以上代码中定义了两个类型，每个类型分别携带了一个方法。</p><p>下来如何调用这两个方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#a6e22e>Num</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>String</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Peple</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>GetName</span>()  
</span></span></code></pre></div><p>先初始化好类型，然后再用“点”符号调用。</p><h2 id=值接受者和指针接收者>值接受者和指针接收者<a hidden class=anchor aria-hidden=true href=#值接受者和指针接收者>#</a></h2><h3 id=1-定义>1. 定义<a hidden class=anchor aria-hidden=true href=#1-定义>#</a></h3><p>在上面的代码中，是否注意到接收者类型有两种，一种是带星号（*People），一种是不带的（People 和 Num）。</p><p><strong>总结为：</strong></p><ul><li><p>带星号的称为：指针接收者。</p></li><li><p>不带星号的称为：值接收者。</p></li></ul><p>还有一种特殊情况就是自定义的类型本身就是引用类型，就算接收者类型声明中带不带”星号“它也属于指针接收者。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>M</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>M</span>) <span style=color:#a6e22e>SetKey</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>string</span>) {  
</span></span><span style=display:flex><span>	(<span style=color:#a6e22e>m</span>)[<span style=color:#a6e22e>key</span>] = <span style=color:#a6e22e>val</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>因为 <code>M</code> 类型依赖的是 <code>map</code> 类型，<code>map</code> 本身就是一个引用类型，因此 <code>m</code> 为指针接收者。</p><h3 id=2-区别>2. 区别<a hidden class=anchor aria-hidden=true href=#2-区别>#</a></h3><p>如果方法是值接收者，执行方法时接收者会被拷贝一份，即使方法修改了接收者的值也不是原来的一份。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>SetName</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>初始化 <code>People</code> 修改 <code>Name</code> 字段。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;苗&#34;</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>SetName</span>(<span style=color:#e6db74>&#34;潇洒哥&#34;</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>Name</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>苗</span>  
</span></span></code></pre></div><p>发现了没，虽然调用了方法进行了修改，但还是不生效。因为 <code>p1</code> 和接收者 <code>p</code> 已经不是一个值了。如果想修改生效，只需把值接收者改为指针接收者。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>People</span>) <span style=color:#a6e22e>SetName</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>name</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h3 id=3-调用时类型转化>3. 调用时类型转化<a hidden class=anchor aria-hidden=true href=#3-调用时类型转化>#</a></h3><p>在调用方法时，不管是值接收者还是指针接收者，调用时的变量类型是否是指针是不影响的。</p><p>例如：<code>People</code> 结构体的方法 <code>SetName</code> 不管是指针还是值接收者，以下代码都可以调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 值  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>SetName</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 指针  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p2</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>People</span>{}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>SetName</span>()  
</span></span></code></pre></div><p>至于为什么？当编译器发现你调用的变量（ p1 和 p2 ）类型和接收者的类型不相同时，也就是一个是指针一个不是，这个时候就会自动转化。</p><p>至于<strong>接收者的值被方法修改时结果会不会改变，和调用变量的类型没关系。</strong></p><h2 id=new-函数使用>New 函数使用<a hidden class=anchor aria-hidden=true href=#new-函数使用>#</a></h2><p>当初始化一个指针变量时，可以使用 "&" 符号，也可以使用 new 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>new(<span style=color:#a6e22e>T</span>)   
</span></span></code></pre></div><p>例如，将 <code>p2 := &amp;People{}</code> 修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p2</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>People</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#e6db74>&#34;老苗&#34;</span>  
</span></span></code></pre></div><p><code>new(People)</code> 和 <code>&amp;People{}</code> 等价。</p><h2 id=私有和公有>私有和公有<a hidden class=anchor aria-hidden=true href=#私有和公有>#</a></h2><p>方法名大写字母开头公有，小写字母开头私有。如果方法所在的包和调用者不是同一个，那私有方法是不能被调用的，只能调用公有方法。</p><p>私有方法只能在同一个包内被调用。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本篇文章完了之后，自定义类型和结构体的知识点就讲完了，如果看到了这就给自己点个赞，坚持住！！！</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.gby.ai/golang-pointer/><span class=title>« 上一页</span><br><span>Go基础系列：14. 指针类型</span></a>
<a class=next href=https://www.gby.ai/golang-struct/><span class=title>下一页 »</span><br><span>Go基础系列：12. 自定义类型和结构体 - 定义</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：13. 自定义类型和结构体 - 方法 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a13.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e6%96%b9%e6%b3%95&amp;url=https%3a%2f%2fwww.gby.ai%2fgolang-method%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：13. 自定义类型和结构体 - 方法 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a13.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e6%96%b9%e6%b3%95"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>