<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag | PrintLove</title><meta name=keywords content="ZigZag"><meta name=description content="Protobuf 底层使用的压缩算法，并使用 Go 语言实现"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/zigzag/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag"><meta property="og:description" content="Protobuf 底层使用的压缩算法，并使用 Go 语言实现"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/zigzag/"><meta property="og:image" content="https://imgs-go-instagram.insloves.com/images/2443-1.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-08T17:45:01+08:00"><meta property="article:modified_time" content="2021-11-08T17:45:01+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://imgs-go-instagram.insloves.com/images/2443-1.jpg"><meta name=twitter:title content="深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag"><meta name=twitter:description content="Protobuf 底层使用的压缩算法，并使用 Go 语言实现"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag","item":"https://www.gby.ai/zigzag/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag","name":"深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag","description":"Protobuf 底层使用的压缩算法，并使用 Go 语言实现","keywords":["ZigZag"],"articleBody":"我原本是想研究 Protobuf 原理呢，但在研究过程中发现 Protobuf 在对负数编码时使用到了 ZigZag 算法，所以才有了本篇。当然你不懂 Protobuf 也完全不影响阅读。\n在聊这个算法之前，我们先聊聊进制、补码相关的东西。如果你懂，那就指向往下翻。\n该篇代码：\nhttps://github.com/miaogaolin/gofirst/tree/main/zigzag\n进制 所谓进制，就是当某一位上的信息满时，需要往前进位。比如，十进制，就是当某一位上的数满十时进位；而某一位上的数满二时进位就是二进制，等等。\n进位之间都可以相互转化，例如：\n十进制：10 → 二进制：1010 → 十六进制：A\n我之前看过一个答案，说：为什么十进制比较通用？\n因为咱人类只有 10 个手指头，数一遍刚好十个数，所以十进制自然就成为默认的进制。那如果人类长 11 手指头，说不定就是十一进制。\n后来计算机的出现，一个数据的有无是最天然的信息承载单元，所以由 0 和 1 组成的二进制很自然成为计算机的进制方式。在此基础上，为了方便信息的使用，又采用了八进制、十六进制。\n好了，进制这个东西就聊到这了。\n三个东西 下来我们对一个十进制正整数表示为二进制，例如：十进制 10 等于二进制 1010。\n那如果二进制表示一个负数，该怎么办？下来我们聊聊。\n在计算机的世界里，定义了原码、反码和补码这几个东西。为了下来讲解简单点，我们假设使用一个字节（1Byte=8bits）表示一个数。\n1. 原码 我们用第一个位表示符号（ 0 为非负数，1 为负数），剩下的位表示值。例如：\n+8 → 原：00001000 -8 → 原: 10001000 2. 反码 我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位，非负数保持不变，负数按位求反。例如：\n+8 → 原：0000 1000 → 反：0000 1000 -8 → 原：1000 1000 → 反：1111 0111 如果我们用原码或者补码来表示整数的二进制，有什么问题吗？表面上看，似乎挺好的。不过仔细思考就会发现两个问题：\n第一，0 居然可以用两个编码表示，+0 和 -0。\n原：0000 0000 → 1000 0000 反：0000 0000 → 1111 1111 第二，计算机不知道符号位的存在，因此参加运算后，会出现一个奇怪的现象。\n原码 1 + (-1)\n→ 0000 0001 + 1000 0001\n→ 1000 0010\n→ -2\n明显是不对的！\n反码 1 + (-1)\n→ 0000 0001 + 1111 111\n→ 1111 1111\n→ -0\n这看起来也怪怪的。\n因此，为了解决这些问题，我们在计算机体系中引入了补码。\n3. 补码 我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位非负数保持不变，负数按位求反末位加一。\n+8 → 原：0000 1000 → 补：0000 1000 -8 → 原：1000 1000 → 补：1111 1000 现在我们看看，把符号带进去运算会出现什么结果？\n1 + (-1)\n→ 0000 0001 + 1111 1111\n→ 0000 0000\n→ 0\n很明显，通过这样的方式，计算机进行运算的时候，就不用关心符号这个问题，统一都按照满 2 进 1 规则处理。\n好了，进制和补码的知识就说到这了，下来进入真正的主题。\nZigZag 在大多数情况下，我们使用到的整数往往会比较小。\n而我们为了在系统通讯时便于传输，往往需要一个整形（int32、int64）作为基本的传输类型。\n因此在大多数系统中，以 4 Bytes 和 8 Bytes 来表示。这样，为了传输一个整型 1，我们需要传输 “00000000 00000000 00000000 00000001” 32 个 bits，而有价值的数据只有 1 位，剩下的都是浪费呀！\n那怎么办呢？ZigZag 应用而生。那这个算法具体的思想是怎么样的呢？\n对于正整数来讲，如果在传输数据时，我们把多余的 0 去掉，或者尽可能的减少无意义的 0。那么我们是不是就可以将数据进行压缩？那怎样进行压缩？\n答案也很简单，例如 00000000 00000000 00000000 00000001 这个数。如果我们只发送 1 位 或者 1 字节 00000001，是不是就会很大程度减少无用的数据？\n当然，如果这个世界上只有正整数，那我们就可以方便的做到这一点。可惜，他居然存在负数！那负数如何表示？\n例如，十进制 -1 的补码表示为 11111111 11111111 11111111 11111111。\n可以看到，前面全是 1，你说怎么弄？\nZigZag 给出了一个很巧妙的方法。我们之前讲补码说过，补码的第一位是符号位，他阻碍了我们对于前导 0 的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位。\n补：11111111 11111111 11111111 11111111\n→ 符号后移：11111111 11111111 11111111 1111111\n但是即使这样，也是很难压缩的。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数，如下：\n十进制：-1\n→ 补：11111111 11111111 11111111 11111111\n→ 符号后移：11111111 11111111 11111111 11111111\n→ ZigZag：00000000 00000000 00000000 00000001\n而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变，如下：\n十进制：1\n→ 补：00000000 00000000 00000000 00000001\n→ 符号后移：00000000 00000000 00000000 00000010\n→ ZigZag：00000000 00000000 00000000 00000010\n这样一弄，正数、0、负数都有同样的表示方法了。我们就可以对小整数进行压缩了，对吧~\n于是，就可以写成如下的代码：\nfunc int32ToZigZag(n int32) int32 { return (n \u003c\u003c 1) ^ (n \u003e\u003e 31) } n \u003c\u003c 1 将整个值左移一位，不管正数、0、负数他们的最后一位都会变成了 0。讲解如下：\n十进制：1\n→ 补：00000000 00000000 00000000 00000001\n→ 左移一位：00000000 00000000 00000000 00000010\n十进制：-1\n→ 补：11111111 11111111 11111111 11111111\n→ 左移一位：11111111 11111111 11111111 11111110\nn \u003e\u003e 31 将符号位放到最后一位。如果是非负数，则为全 0；如果是负数，就是全 1。讲解如下：\n十进制：1\n→ 补：00000000 00000000 00000000 00000001\n→ 右移 31 位：00000000 00000000 00000000 00000000\n十进制：-1\n→ 补：11111111 11111111 11111111 11111111\n→ 右移 31 位：11111111 11111111 11111111 11111111\n最后这一步很巧妙，将两者进行按位异或操作。\n十进制：1\n→ n \u003c\u003c 1 ：00000000 00000000 00000000 00000010 ^\nn \u003e\u003e 31： 00000000 00000000 00000000 00000000\n→ 00000000 00000000 00000000 00000010\n可以看到最终结果，数据位保持不变，而符号位也保持不变，只是符号位移动到了最后一位。\n十进制：-1\n→ n \u003c\u003c 1：11111111 11111111 11111111 11111110 ^\nn \u003e\u003e 31：11111111 11111111 11111111 11111111\n→ 00000000 00000000 00000000 00000001\n可以看到，数据位全部反转了，而符号位保持不变，且移动到了最后一位。这一步真的写的很巧妙！\nZigZag 还原代码如下：\nfunc toInt32(zz int32) int32 { return int32(uint32(zz)\u003e\u003e1) ^ -(zz \u0026 1) } 类似的，我们还原的代码就反过来写就可以了。不过这里要注意一点，就是右移的时候，需要用不带符号的移动，否则如果第一位是 1 的时，移动时会补 1。所以，使用了无符号的移位操作 uint32(zz)\u003e\u003e1。\n好了，有了该算法，就可以得到一个有前导 0 的整数。只是，该数据依然使用 4 字节存储。下来我们要考虑如何尽可能的减少字节数，并且还能还原。\n例如，我们将 1 按照如上算法转化得到：00000000 00000000 00000000 00000010。\n下来我们最好只需要发送 2 bits（10），或者发送 8 bits（00000010），把前面的 0 全部省掉。因为数据传输是以字节为单位，所以，我们最好保持 8 bits 这样的单位。所以我们有 2 种做法：\n我们可以额外增加一个字节，用来表示接下来有效的字节长度，比如：00000001 00000010，前 8 位表示接下来有 1 个字节需要传输，第二个 8 位表示真正的数据。这种方式虽然能达到我们想要的效果，但是莫名的增加一个字节的额外浪费。有没有不浪费的办法呢？ 字节自表示方法。ZigZag 引入了一个方法，就是用字节自己表示自己。具体怎么做呢？我们来看看代码。 func compress(zz int32) []byte { var res []byte size := binary.Size(zz) for i := 0; i \u003c size; i++ { if (zz \u0026 ^0x7F) != 0 { res = append(res, byte(0x80|(zz\u00260x7F))) zz = int32(uint32(zz) \u003e\u003e 7) } else { res = append(res, byte(zz\u00260x7F)) break } } return res } 大家先看看代码里那个 ^0x7F，他究竟是个什么数呢？\n^0x7F：11111111 11111111 11111111 10000000 他就是从倒数第八位开始，高位全为 1 的数。他的作用就是去除最后七位后，判断还有没有信息。\n我们把 ZigZag 值传递给这个函数，这个函数就将这个值从低位到高位切分成每 7 bits 一组，如果高位还有有效信息，则给这 7 bits 补上 1 个 bit 的 1（0x80）。如此反复 直到全是前导 0，便结束算法。\n举个例来讲：\n十进制：-1000\n→ 补：11111111 11111111 11111100 00011000\n→ ZigZag：00000000 00000000 00000111 11001111\n我们先按照七位一组的方式将上面的数字划开，0000 0000000 0000000 0001111 1001111。\n详细步骤如下：\n他跟 ^0x7F 做与操作的结果，高位还有信息，所以，我们把低 7 位取出来，并在倒数第八位上补一个 1（0x80）：11001111。 将这个数右移七位，0000 0000000 0000000 0000000 0001111。 再取出最后的七位，跟 ^0x7F 做与操作，发现高位已经没有信息了（全是 0），那么我们就将最后 8 位完整的取出来：00001111，并且跳出循环，终止算法。 最终，我们就得到了两个字节的数据 [11001111, 00001111]。 通过上面几步，我们就将一个 4 字节的 ZigZag 变换后的数字变成了一个 2 字节的数据。如果我们是网络传输的话，就直接发送这 2 个字节给对方进程。对方进程收到数据后，就可以进行数据的组装还原了。具体的还原操作如下：\nfunc decompress(zzByte []byte) int32 { var res int32 for i, offset := 0, 0; i \u003c len(zzByte); i, offset = i+1, offset+7 { b := zzByte[i] if (b \u0026 0x80) == 0x80 { res |= int32(b\u00260x7F) \u003c\u003c offset } else { res |= int32(b) \u003c\u003c offset break } } return res } 整个过程就和压缩的时候是逆向的，对于每一个字节，先看最高一位是否有 1（0x80）。如果有，就说明不是最后一个数据字节包，那取这个字节的最后七位进行拼装。否则，说明就是已经到了最后一个字节了，那直接拼装后，跳出循环，算法结束。最终得到 4 字节的整数。\n结语 算法不是很复杂，遇到哪块不懂了，就好好观察想想，这也是对 Protobuf 原理理解的重要部分。如果有不懂的，就在下方给我留言！\n完整代码：\nhttps://github.com/miaogaolin/gofirst/tree/main/zigzag\n","wordCount":"612","inLanguage":"zh","image":"https://imgs-go-instagram.insloves.com/images/2443-1.jpg","datePublished":"2021-11-08T17:45:01+08:00","dateModified":"2021-11-08T17:45:01+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/zigzag/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag</h1><div class=post-meta><span title='2021-11-08 17:45:01 +0800 CST'>2021-11-08</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/%e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a2.%20%e7%a0%94%e7%a9%b6%20Protobuf%20%e6%97%b6%e5%8f%91%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%8c%ba%e5%a5%bd%e7%9a%84%e7%ae%97%e6%b3%95%20%e2%80%94%20ZigZag.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#进制>进制</a></li><li><a href=#三个东西>三个东西</a><ul><li><a href=#1-原码>1. 原码</a></li><li><a href=#2-反码>2. 反码</a></li><li><a href=#3-补码>3. 补码</a></li></ul></li><li><a href=#zigzag>ZigZag</a></li><li><a href=#结语>结语</a></li></ul></nav></div></details></div><div class=post-content><p>我原本是想研究 Protobuf 原理呢，但在研究过程中发现 Protobuf 在对负数编码时使用到了 ZigZag 算法，所以才有了本篇。当然你不懂 Protobuf 也完全不影响阅读。</p><p>在聊这个算法之前，我们先聊聊进制、补码相关的东西。如果你懂，那就指向往下翻。</p><p>该篇代码：</p><p><a href=https://github.com/miaogaolin/gofirst/tree/main/zigzag>https://github.com/miaogaolin/gofirst/tree/main/zigzag</a></p><h2 id=进制>进制<a hidden class=anchor aria-hidden=true href=#进制>#</a></h2><p>所谓进制，就是当某一位上的信息满时，需要往前进位。比如，十进制，就是当某一位上的数满十时进位；而某一位上的数满二时进位就是二进制，等等。</p><p>进位之间都可以相互转化，例如：</p><p>十进制：10 → 二进制：1010 → 十六进制：A</p><p>我之前看过一个答案，说：为什么十进制比较通用？</p><p>因为咱人类只有 10 个手指头，数一遍刚好十个数，所以十进制自然就成为默认的进制。那如果人类长 11 手指头，说不定就是十一进制。</p><p>后来计算机的出现，一个数据的有无是最天然的信息承载单元，所以由 0 和 1 组成的二进制很自然成为计算机的进制方式。在此基础上，为了方便信息的使用，又采用了八进制、十六进制。</p><p>好了，进制这个东西就聊到这了。</p><h2 id=三个东西>三个东西<a hidden class=anchor aria-hidden=true href=#三个东西>#</a></h2><p>下来我们对一个十进制正整数表示为二进制，例如：十进制 10 等于二进制 1010。</p><p>那如果二进制表示一个负数，该怎么办？下来我们聊聊。</p><p>在计算机的世界里，定义了原码、反码和补码这几个东西。为了下来讲解简单点，我们假设使用一个字节（1Byte=8bits）表示一个数。</p><h3 id=1-原码>1. 原码<a hidden class=anchor aria-hidden=true href=#1-原码>#</a></h3><p>我们用第一个位表示符号（ 0 为非负数，1 为负数），剩下的位表示值。例如：</p><ul><li>+8 → 原：00001000</li><li>-8 → 原: 10001000</li></ul><h3 id=2-反码>2. 反码<a hidden class=anchor aria-hidden=true href=#2-反码>#</a></h3><p>我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位，非负数保持不变，负数按位求反。例如：</p><ul><li>+8 → 原：0000 1000 → 反：0000 1000</li><li>-8 → 原：1000 1000 → 反：1111 0111</li></ul><p>如果我们用原码或者补码来表示整数的二进制，有什么问题吗？表面上看，似乎挺好的。不过仔细思考就会发现两个问题：</p><p><strong>第一</strong>，0 居然可以用两个编码表示，+0 和 -0。</p><ul><li>原：0000 0000 → 1000 0000</li><li>反：0000 0000 → 1111 1111</li></ul><p><strong>第二</strong>，计算机不知道符号位的存在，因此参加运算后，会出现一个奇怪的现象。</p><ul><li>原码</li></ul><p>1 + (-1)</p><p>→ 0000 0001 + 1000 0001</p><p>→ 1000 0010</p><p>→ -2</p><p>明显是不对的！</p><ul><li>反码</li></ul><p>1 + (-1)</p><p>→ 0000 0001 + 1111 111</p><p>→ 1111 1111</p><p>→ -0</p><p>这看起来也怪怪的。</p><p>因此，为了解决这些问题，我们在计算机体系中引入了补码。</p><h3 id=3-补码>3. 补码<a hidden class=anchor aria-hidden=true href=#3-补码>#</a></h3><p>我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位非负数保持不变，负数按位求反末位加一。</p><ul><li>+8 → 原：0000 1000 → 补：0000 1000</li><li>-8 → 原：1000 1000 → 补：1111 1000</li></ul><p>现在我们看看，把符号带进去运算会出现什么结果？</p><p>1 + (-1)</p><p>→ 0000 0001 + 1111 1111</p><p>→ 0000 0000</p><p>→ 0</p><p>很明显，通过这样的方式，计算机进行运算的时候，就不用关心符号这个问题，统一都按照满 2 进 1 规则处理。</p><p>好了，进制和补码的知识就说到这了，下来进入真正的主题。</p><h2 id=zigzag>ZigZag<a hidden class=anchor aria-hidden=true href=#zigzag>#</a></h2><p>在大多数情况下，我们使用到的整数往往会比较小。</p><p>而我们为了在系统通讯时便于传输，往往需要一个整形（int32、int64）作为基本的传输类型。</p><p>因此在大多数系统中，以 4 Bytes 和 8 Bytes 来表示。这样，为了传输一个整型 1，我们需要传输 “00000000 00000000 00000000 00000001” 32 个 bits，而有价值的数据只有 1 位，剩下的都是浪费呀！</p><p>那怎么办呢？ZigZag 应用而生。那这个算法具体的思想是怎么样的呢？</p><p>对于正整数来讲，如果在传输数据时，我们把多余的 0 去掉，或者尽可能的减少无意义的 0。那么我们是不是就可以将数据进行压缩？那怎样进行压缩？</p><p>答案也很简单，例如 00000000 00000000 00000000 00000001 这个数。如果我们只发送 1 位 或者 1 字节 00000001，是不是就会很大程度减少无用的数据？</p><p>当然，如果这个世界上只有正整数，那我们就可以方便的做到这一点。可惜，他居然存在负数！那负数如何表示？</p><p>例如，十进制 -1 的补码表示为 11111111 11111111 11111111 11111111。</p><p>可以看到，前面全是 1，你说怎么弄？</p><p>ZigZag 给出了一个很巧妙的方法。我们之前讲补码说过，补码的第一位是符号位，他阻碍了我们对于前导 0 的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位。</p><p>补：<code>1</code>1111111 11111111 11111111 11111111</p><p>→ 符号后移：11111111 11111111 11111111 111111<code>1</code></p><p>但是即使这样，也是很难压缩的。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数，如下：</p><p>十进制：-1</p><p>→ 补：<code>1</code>1111111 11111111 11111111 11111111</p><p>→ 符号后移：11111111 11111111 11111111 1111111<code>1</code></p><p>→ ZigZag：00000000 00000000 00000000 0000000<code>1</code></p><p>而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变，如下：</p><p>十进制：1</p><p>→ 补：<code>0</code>0000000 00000000 00000000 00000001</p><p>→ 符号后移：00000000 00000000 00000000 0000001<code>0</code></p><p>→ ZigZag：00000000 00000000 00000000 0000001<code>0</code></p><p>这样一弄，正数、0、负数都有同样的表示方法了。我们就可以对小整数进行压缩了，对吧~</p><p>于是，就可以写成如下的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>int32ToZigZag</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int32</span>) <span style=color:#66d9ef>int32</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>) ^ (<span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p><code>n &lt;&lt; 1</code> 将整个值左移一位，不管正数、0、负数他们的最后一位都会变成了 0。讲解如下：</p><p>十进制：1</p><p>→ 补：<code>0</code>0000000 00000000 00000000 00000001</p><p>→ 左移一位：00000000 00000000 00000000 00000010</p><p>十进制：-1</p><p>→ 补：<code>1</code>1111111 11111111 11111111 11111111</p><p>→ 左移一位：11111111 11111111 11111111 11111110</p><p><code>n >> 31</code> 将符号位放到最后一位。如果是非负数，则为全 0；如果是负数，就是全 1。讲解如下：</p><p>十进制：1</p><p>→ 补：<code>0</code>0000000 00000000 00000000 00000001</p><p>→ 右移 31 位：00000000 00000000 00000000 0000000<code>0</code></p><p>十进制：-1</p><p>→ 补：<code>1</code>1111111 11111111 11111111 11111111</p><p>→ 右移 31 位：11111111 11111111 11111111 1111111<code>1</code></p><p>最后这一步很巧妙，将两者进行按位异或操作。</p><p>十进制：1</p><p>→ <code>n &lt;&lt; 1</code> ：00000000 00000000 00000000 00000010 ^</p><p><code>n >> 31</code>： 00000000 00000000 00000000 0000000<code>0</code></p><p>→ 00000000 00000000 00000000 0000001<code>0</code></p><p>可以看到最终结果，数据位保持不变，而符号位也保持不变，只是符号位移动到了最后一位。</p><p>十进制：-1</p><p>→ <code>n &lt;&lt; 1</code>：11111111 11111111 11111111 11111110 ^</p><p><code>n >> 31</code>：11111111 11111111 11111111 1111111<code>1</code></p><p>→ 00000000 00000000 00000000 0000000<code>1</code></p><p>可以看到，数据位全部反转了，而符号位保持不变，且移动到了最后一位。这一步真的写的很巧妙！</p><p>ZigZag 还原代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>toInt32</span>(<span style=color:#a6e22e>zz</span> <span style=color:#66d9ef>int32</span>) <span style=color:#66d9ef>int32</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> int32(uint32(<span style=color:#a6e22e>zz</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>) ^ <span style=color:#f92672>-</span>(<span style=color:#a6e22e>zz</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>类似的，我们还原的代码就反过来写就可以了。不过这里要注意一点，就是右移的时候，需要用不带符号的移动，否则如果第一位是 1 的时，移动时会补 1。所以，使用了无符号的移位操作 <code>uint32(zz)>>1</code>。</p><p>好了，有了该算法，就可以得到一个有前导 0 的整数。只是，该数据依然使用 4 字节存储。下来我们要考虑如何尽可能的减少字节数，并且还能还原。</p><p>例如，我们将 1 按照如上算法转化得到：00000000 00000000 00000000 00000010。</p><p>下来我们最好只需要发送 2 bits（10），或者发送 8 bits（00000010），把前面的 0 全部省掉。因为数据传输是以字节为单位，所以，我们最好保持 8 bits 这样的单位。所以我们有 2 种做法：</p><ul><li>我们可以额外增加一个字节，用来表示接下来有效的字节长度，比如：00000001 00000010，前 8 位表示接下来有 1 个字节需要传输，第二个 8 位表示真正的数据。这种方式虽然能达到我们想要的效果，但是莫名的增加一个字节的额外浪费。有没有不浪费的办法呢？</li><li>字节自表示方法。ZigZag 引入了一个方法，就是用字节自己表示自己。具体怎么做呢？我们来看看代码。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>compress</span>(<span style=color:#a6e22e>zz</span> <span style=color:#66d9ef>int32</span>) []<span style=color:#66d9ef>byte</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>res</span> []<span style=color:#66d9ef>byte</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Size</span>(<span style=color:#a6e22e>zz</span>)  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>zz</span> <span style=color:#f92672>&amp;</span> ^<span style=color:#ae81ff>0x7F</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, byte(<span style=color:#ae81ff>0x80</span>|(<span style=color:#a6e22e>zz</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x7F</span>)))  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>zz</span> = int32(uint32(<span style=color:#a6e22e>zz</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>)  
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, byte(<span style=color:#a6e22e>zz</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x7F</span>))  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>大家先看看代码里那个 ^0x7F，他究竟是个什么数呢？</p><ul><li>^0x7F：11111111 11111111 11111111 10000000</li></ul><p>他就是从倒数第八位开始，高位全为 1 的数。他的作用就是去除最后七位后，判断还有没有信息。</p><p>我们把 ZigZag 值传递给这个函数，这个函数就将这个值从低位到高位切分成每 7 bits 一组，如果高位还有有效信息，则给这 7 bits 补上 1 个 bit 的 1（0x80）。如此反复 直到全是前导 0，便结束算法。</p><p>举个例来讲：</p><p>十进制：-1000</p><p>→ 补：<code>1</code>1111111 11111111 11111100 00011000</p><p>→ ZigZag：00000000 00000000 00000111 1100111<code>1</code></p><p>我们先按照七位一组的方式将上面的数字划开，0000 0000000 0000000 0001111 1001111。</p><p>详细步骤如下：</p><ol><li>他跟 ^0x7F 做与操作的结果，高位还有信息，所以，我们把低 7 位取出来，并在倒数第八位上补一个 1（0x80）：11001111。</li><li>将这个数右移七位，0000 0000000 0000000 0000000 0001111。</li><li>再取出最后的七位，跟 ^0x7F 做与操作，发现高位已经没有信息了（全是 0），那么我们就将最后 8 位完整的取出来：00001111，并且跳出循环，终止算法。</li><li>最终，我们就得到了两个字节的数据 [11001111, 00001111]。</li></ol><p>通过上面几步，我们就将一个 4 字节的 ZigZag 变换后的数字变成了一个 2 字节的数据。如果我们是网络传输的话，就直接发送这 2 个字节给对方进程。对方进程收到数据后，就可以进行数据的组装还原了。具体的还原操作如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>decompress</span>(<span style=color:#a6e22e>zzByte</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>int32</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>res</span> <span style=color:#66d9ef>int32</span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>offset</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>zzByte</span>); <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>offset</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>offset</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span> {  
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>zzByte</span>[<span style=color:#a6e22e>i</span>]  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x80</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>res</span> <span style=color:#f92672>|=</span> int32(<span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x7F</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>offset</span>  
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>res</span> <span style=color:#f92672>|=</span> int32(<span style=color:#a6e22e>b</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>offset</span>  
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>整个过程就和压缩的时候是逆向的，对于每一个字节，先看最高一位是否有 1（0x80）。如果有，就说明不是最后一个数据字节包，那取这个字节的最后七位进行拼装。否则，说明就是已经到了最后一个字节了，那直接拼装后，跳出循环，算法结束。最终得到 4 字节的整数。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>算法不是很复杂，遇到哪块不懂了，就好好观察想想，这也是对 Protobuf 原理理解的重要部分。如果有不懂的，就在下方给我留言！</p><p>完整代码：</p><p><a href=https://github.com/miaogaolin/gofirst/tree/main/zigzag>https://github.com/miaogaolin/gofirst/tree/main/zigzag</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.gby.ai/protobuf/><span class=title>« 上一页</span><br><span>深入微服务：3. Protobuf 为啥比 JSON、XML 牛？</span></a>
<a class=next href=https://www.gby.ai/grpc-start/><span class=title>下一页 »</span><br><span>深入微服务：1. 开篇 gRPC 环境&启动</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag on x" href="https://x.com/intent/tweet/?text=@laomiao_ %e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a2.%20%e7%a0%94%e7%a9%b6%20Protobuf%20%e6%97%b6%e5%8f%91%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%8c%ba%e5%a5%bd%e7%9a%84%e7%ae%97%e6%b3%95%20%e2%80%94%20ZigZag&amp;url=https%3a%2f%2fwww.gby.ai%2fzigzag%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag on email" href="mailto:mglluoye@gmail.com?subject=%e6%b7%b1%e5%85%a5%e5%be%ae%e6%9c%8d%e5%8a%a1%ef%bc%9a2.%20%e7%a0%94%e7%a9%b6%20Protobuf%20%e6%97%b6%e5%8f%91%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%8c%ba%e5%a5%bd%e7%9a%84%e7%ae%97%e6%b3%95%20%e2%80%94%20ZigZag"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>