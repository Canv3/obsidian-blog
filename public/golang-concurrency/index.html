<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：18. 并发 | PrintLove</title><meta name=keywords content="Goroutine,channel"><meta name=description content="并发与并行的区别，什么是Goroutine，什么是通道，select语句使用等等"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.printlove.cn/golang-concurrency/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：18. 并发"><meta property="og:description" content="并发与并行的区别，什么是Goroutine，什么是通道，select语句使用等等"><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/golang-concurrency/"><meta property="og:image" content="https://images.unsplash.com/photo-1557837847-424ee109654e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxfHxNYW55fGVufDB8MHx8fDE3MDMwNzA0MDN8MA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-22T10:12:00+08:00"><meta property="article:modified_time" content="2021-10-22T10:12:00+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1557837847-424ee109654e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxfHxNYW55fGVufDB8MHx8fDE3MDMwNzA0MDN8MA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：18. 并发"><meta name=twitter:description content="并发与并行的区别，什么是Goroutine，什么是通道，select语句使用等等"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：18. 并发","item":"https://www.printlove.cn/golang-concurrency/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：18. 并发","name":"Go基础系列：18. 并发","description":"并发与并行的区别，什么是Goroutine，什么是通道，select语句使用等等","keywords":["Goroutine","channel"],"articleBody":"学到什么 并发与并行的区别？ 什么是 Goroutine？ 什么是通道？ Goroutine 如何通信？ 相关函数的使用？ select 语句如何使用？ 并发与并行 为了更有意思的解释这个概念，我借用知乎上的一个回答：\n你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。\n并行的关键是你有同时处理多个任务的能力。\n对应到 CPU 上，如果是多核它就有同时执行的能力，即有并行的能力。\n对于 Go 语言，它自行安排了我们的代码合适并发合适并行。\n什么是 Goroutine 学会这个就知道怎么写一个并发程序，用起来很简单的，现在开始。\nGoroutine 是 Go 语言中的协程，其它语言称为的协程字面上叫 Coroutine，简单理解下就是比线程更轻量的一个玩意。\n再说白了，就是可以异步执行函数。\nmain Goroutine 当启动 main 入口函数时，后台就自动跑了一个 main Goroutine，还原给大家看看。\npackage main func main() { panic(\"看这里\") } 执行上面代码，会输出如下部分信息：\npanic: 看这里 goroutine 1 [running]: main.main() 从结果中可以看到，出现了一个 goroutine 字眼，它对应的索引为 1。\n创建 Goroutine 创建 Goroutine 很简单，只需要在函数前增加一个 go 关键字，格式如下：\ngo fun1(...) 也支持匿名函数。\ngo func(...){ // ... }(...) go 关键字后的函数可以写返回值，但无效。因为 Goroutine 是异步的，所以没法接受。 下来看一个完整的例子：\npackage main import ( \"fmt\" ) func PrintA() { fmt.Println(\"A\") } func main() { go PrintA() fmt.Println(\"main\") } 看上面 main 函数只有两行：\n第一行：创建一个 Goroutine，异步打印“A”字符串。 第二行：打印 “main” 字符串。 现在先停留一会，想想执行该代码后，输出结果是啥。\n结果如下：\nmain 你没看错，没有输出“A”字符串。\n因为 go PrintA() 创建的 Goroutine 它是异步执行，main 函数执行完退出程序时，也不会管它。所以下来看如何让 main 函数等待 Goroutine 执行完。\n方法一：使用 time.Sleep 函数。\nfunc main() { go PrintA() fmt.Println(\"main\") time.Sleep(time.Second) } // 输出 main A main 函数退出前让等一会。\n方法二：使用空的 select 语句，非空的 select 用法会配合通道一块讲解。\nfunc main() { go PrintA() fmt.Println(\"main\") select {} } // 输出 main A fatal error: all goroutines are asleep - deadlock! ... \"A\" 字符串是输出了，但程序也出现异常了。\n原因是，当程序中存在运行的 Goroutine，select{} 就会一直等待，如果 Goroutine 都执行结束了，没有什么可等待的了，就会抛出异常。\n在真实项目中，出现异常自然不对，那 select{} 使用场景是啥，例如：\n爬虫项目，创建了 Goroutine，需要一直爬取数据，不需要停止。 方法三：使用 WaitGroup 类型等待 Goroutine 结束，项目中常常使用，完整例子如下：\npackage main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func PrintA() { fmt.Println(\"A\") wg.Done() } func main() { wg.Add(1) go PrintA() wg.Wait() fmt.Println(\"main\") } 声明 WaitGroup 类型变量 wg，使用时无需初始化。 wg.Add(1) 表示需要等待一个 Goroutine，如果有两个，使用 Add(2)。 当一个 Goroutine 运行完后使用 wg.Done() 通知。 wg.Wait() 等待 Goroutine 执行完。 控制并发数 Go 语言中可以控制使用 CPU 的核心数量，从 Go1.5 版本开始，默认设置为 CPU 的总核心数。如果想自定义设置，使用如下函数：\nnum := 2 runtime.GOMAXPROCS(num) num 如果大于 CPU 的核心数，也是允许的，Go 语言调度器会将很多的 Goroutine 分配到不同的处理器上。\n什么是通道 现在明白了怎么创建 Goroutine 后，下一步就要知道它们之间要如何通信。\nGoroutine 通信使用“通道 (channel)”，如果 Goroutine1 想发送数据给 Goroutine2，就把数据放到通道里，Goroutine2 直接从通道里拿就行，反过来也是一样。\n在给通道放数据时，也可以指定通道放置的数据类型。\n创建通道 创建通道时，分为无缓冲和有缓冲两种。\n1. 无缓冲 strChan := make(chan string) 定义了一个存储数据类型为 string 的无缓冲通道，如果想存储任意类型，那数据类型设置为空接口。\nallChan := make(chan interface{}) 创建好了通道，下来就要给通道里放数据。\nstrChan := make(chan string) strChan \u003c- \"老苗\" 使用 \"\u003c-\" 操作符链接数据，表示将“老苗”字符串送入 strChan 通道变量。\n但这样放数据是会报错的，因为 strChan 变量是无缓冲通道，放入数据时 main 函数会一直等待，因此会造成死锁。\n如果想解决死锁情况，就要保证有地方在异步读通道，因此需要创建一个 Goroutine 来负责。\n例子如下：\n// concurrency/channel/main.go package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func Read(strChan chan string) { data := \u003c-strChan fmt.Println(data) wg.Done() } func main() { wg.Add(1) strChan := make(chan string) go Read(strChan) strChan \u003c- \"老苗\" wg.Wait() } // 输出 老苗 Read 函数负责读取通道数据，并打印。 通道是引用类型，因此传递时无需使用指针。 \u003c-strChan 表示从通道里拿数据，如果通道里没有数据它会进行阻塞。 wg.Wait() 等待 Read 异步函数执行完。 2. 有缓冲 读了上面就会了解到，对于无缓冲通道，它会产生阻塞。为了不让阻塞，必须创建一个 Goroutine 负责从通道读取才行。\n而有缓冲的通道，会有缓冲的余地，具体来看看。\n创建缓冲通道，如下：\nbufferChan := make(chan string, 3) 创建了一个存储数据类型为 string 的通道。 可以缓冲 3 个数据，即给通道送入 3 个数据不会进行阻塞。 测试如下：\n// concurrency/bufferchannel/main.go package main import \"fmt\" func main() { bufferChan := make(chan string, 3) bufferChan\u003c-\"a\" bufferChan\u003c-\"b\" bufferChan\u003c-\"c\" fmt.Println(\u003c-bufferChan) } // 输出 a 给 bufferChan 变量存入 3 个字符串。 存入 3 个数据时不会阻塞，当存入数量超过 3 时，就需要 Goroutine 异步读取。 缓冲通道何时使用，例如：\n爬虫数据，第 1 个 Goroutine 负责爬取数据，第 2 个 Goroutine 负责处理和存储数据。 当第 1 个的处理速度大于第 2 个时，可以使用缓冲通道暂存起来。\n暂存起来后，第 1 个 Goroutine 就可以继续爬取，而不像无缓冲通道，放入数据时会阻塞，直到通道数据被读出，才能进行。\n为了加深印象，再来一张图：\n图解：\nbufferChan 长度为 3 的缓冲通道，并且已存入 2 个数据。 看图中的两个箭头，箭头在 bufferChan 右边，表示存，左边表示取。 按照先入先出规则存取。 单向通道 现在知道了如何创建一个双向通道，双向通道指的就是即可以存，又可以取。\n那单向通道创建如下：\nreadChan := make(\u003c-chan string) writeChan := make(chan\u003c- string) readChan 只能读取数据。 writeChan 只能存取数据。 但这样创建的通道是无法传递数据的，为什么？\n因为，如果只能读的通道，没法存数据，那我存了个寂寞。而存的通道，我数据拿不出来，又有何用。\n现在看看如何正确使用单向通道的例子，如下：\n// concurrency/onechannel/main.go package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup // 写通道 func write(data chan\u003c- int) { data\u003c-520 wg.Done() } // 读通道 func read(data \u003c-chan int) { fmt.Println(\u003c-data) wg.Done() } func main() { wg.Add(2) dataChan := make(chan int) go write(dataChan) go read(dataChan) wg.Wait() } // 输出 520 创建了两个 Goroutine，read 函数负责只读，write 函数负责只写。 通道传递时，将双向通道转化为单向通道。 遍历通道 在实际项目中，通道里会产生大量的数据，这时候就要循环的从通道里读取。\n现在改写单向通道写入数据的例子：\nfunc write(data chan\u003c- int) { for i := 0; i \u003c 10; i++ { data\u003c-i } wg.Done() } 这段代码是给通道里循环写入数字。\n下来使用两种方式循环读取通道数据。\n1. 死循环 func read(data \u003c-chan int) { for { d := \u003c-data fmt.Println(d) } wg.Done() } 使用死循环读取数据，但这个有个问题，什么时候退出 for 循环？\nread 函数在读取通道时是不知道数据写入完了，如果读取不到数据，它会一直阻塞，因此，如果写数据完成时，需要使用 close 函数关闭通道。\nfunc write(data chan\u003c- int) { // ... close(data) wg.Done() } 关闭后，读取通道时也需要检测判断。\nfunc read(data \u003c-chan int) { for { d, ok := \u003c-data if !ok { break } fmt.Println(d) } wg.Done() } ok 变量为 false 时，表示通道已关闭。 关闭通道后，ok 变量不会立马变成 false，而是等已放入通道的数据都读取完。 ch := make(chan string, 1) ch \u003c- \"a\" close(ch) val, ok := \u003c-ch fmt.Println(val, ok) val1, ok1 := \u003c-ch fmt.Println(val1, ok1) // 输出 a true false 2. for-range 也可以使用 for-range 语句读取通道，这比死循环使用起来简单一点。\nfunc read(data \u003c-chan int) { for d := range data{ fmt.Println(d) } wg.Done() } 如果想退出 for-range 语句，也需要关闭通道。 如果关闭通道后，不需要增加 ok 判断，等通道数据读取完，自行会退出。 通道函数 使用 len 函数获取通道里还有多少个消息未读，cap 函数获取通道的缓冲大小\nch := make(chan int, 3) ch\u003c-1 fmt.Println(len(ch)) fmt.Println(cap(ch)) // 输出 1 3 select 语句 上面已经知道了空 select 语句的作用，现在看看非空 select 的用法。\nselect 语句 和 switch 语句类似，它也有 case 分支，也有 default 分支，但 select 语句的不同点有两个：\ncase 分支只能是“读通道”或“写通道”，如果读写成功，即不阻塞，则 case 分支就满足。 fallthrough 关键字不能使用。 1. 无 default 分支 select 语句会在 case 分支中选择一个可读写成功的通道。\n正确例子：\n// concurrency/select/main.go package main import \"fmt\" func main() { ch1 := make(chan int, 1) ch2 := make(chan int, 1) ch1 \u003c- 1 select { case v, ok := \u003c-ch1: if ok { fmt.Println(\"ch1通道\", v) } case v, ok := \u003c-ch2: if ok { fmt.Println(\"ch2通道\", v) } } } // 输出 ch1通道 1 ch1 通道有数据，因此进入了第一个 case 分支。 这里展示了读通道，也可以给通道写数据，例：case ch2\u003c-2。 如果删除 ch1 \u003c- 1 ，select 语句会在 main 函数中一直等待，因此会造成死锁。 fatal error: all goroutines are asleep - deadlock! goroutine 1 [select]: main.main() C:/workspace/go/src/gobasic/cocurrency/select/main.go:9 +0xe7 2. 有 default 分支 为了防止 select 语句出现死锁，可以增加 default 分支。意思就是，当没有一个 case 分支可以进行通道读写，那就走 default 分支。\n// ... func main() { ch1 := make(chan int, 1) ch2 := make(chan int, 1) select { case v, ok := \u003c-ch1: if ok { fmt.Println(\"ch1通道\", v) } case v, ok := \u003c-ch2: if ok { fmt.Println(\"ch2通道\", v) } default: fmt.Println(\"没有可读写通道\") } } // 输出 没有可读写通道 总结 这节课很关键，也是很容易出现问题的地方，我再针对重点的重点强调一下：\n在函数调用前增加 go 关键字，表示创建 Goroutine。 执行 Goroutine 不会同步等待，常用的使用 WaitGroup 类型处理。 Goroutine 的通信使用通道传输。 无缓冲的通道，不要进行同步读写，不然会阻塞。 最后，再揣摩一句话，不要用共享内存来通信，要用通信来共享内存。\n","wordCount":"838","inLanguage":"zh","image":"https://images.unsplash.com/photo-1557837847-424ee109654e?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxfHxNYW55fGVufDB8MHx8fDE3MDMwNzA0MDN8MA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-10-22T10:12:00+08:00","dateModified":"2021-10-22T10:12:00+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/golang-concurrency/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：18. 并发</h1><div class=post-meta><span title='2021-10-22 10:12:00 +0800 CST'>2021-10-22</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a18.%20%e5%b9%b6%e5%8f%91.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#并发与并行>并发与并行</a></li><li><a href=#什么是-goroutine>什么是 Goroutine</a></li><li><a href=#main-goroutine>main Goroutine</a></li><li><a href=#创建-goroutine>创建 Goroutine</a></li><li><a href=#控制并发数>控制并发数</a></li><li><a href=#什么是通道>什么是通道</a></li><li><a href=#创建通道>创建通道</a><ul><li><a href=#1-无缓冲>1. 无缓冲</a></li><li><a href=#2-有缓冲>2. 有缓冲</a></li></ul></li><li><a href=#单向通道>单向通道</a></li><li><a href=#遍历通道>遍历通道</a><ul><li><a href=#1-死循环>1. 死循环</a></li><li><a href=#2-for-range>2. for-range</a></li></ul></li><li><a href=#通道函数>通道函数</a></li><li><a href=#select-语句>select 语句</a><ul><li><a href=#1-无-default-分支>1. 无 default 分支</a></li><li><a href=#2-有-default-分支>2. 有 default 分支</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>并发与并行的区别？</li><li>什么是 Goroutine？</li><li>什么是通道？</li><li>Goroutine 如何通信？</li><li>相关函数的使用？</li><li><code>select</code> 语句如何使用？</li></ol><h2 id=并发与并行>并发与并行<a hidden class=anchor aria-hidden=true href=#并发与并行>#</a></h2><p>为了更有意思的解释这个概念，我借用知乎上的一个回答：</p><ul><li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li><li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li><li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li></ul><p>并发的关键是你有处理多个任务的能力，不一定要同时。</p><p>并行的关键是你有同时处理多个任务的能力。</p><p>对应到 CPU 上，如果是多核它就有同时执行的能力，即有并行的能力。</p><p>对于 Go 语言，它自行安排了我们的代码合适并发合适并行。</p><h2 id=什么是-goroutine>什么是 Goroutine<a hidden class=anchor aria-hidden=true href=#什么是-goroutine>#</a></h2><p>学会这个就知道怎么写一个并发程序，用起来很简单的，现在开始。</p><p>Goroutine 是 Go 语言中的协程，其它语言称为的协程字面上叫 Coroutine，简单理解下就是比线程更轻量的一个玩意。</p><p>再说白了，就是可以异步执行函数。</p><h2 id=main-goroutine>main Goroutine<a hidden class=anchor aria-hidden=true href=#main-goroutine>#</a></h2><p>当启动 main 入口函数时，后台就自动跑了一个 main Goroutine，还原给大家看看。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;看这里&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>执行上面代码，会输出如下部分信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>panic</span>: <span style=color:#960050;background-color:#1e0010>看这里</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:  
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()  
</span></span></code></pre></div><p>从结果中可以看到，出现了一个 <code>goroutine</code> 字眼，它对应的索引为 1。</p><h2 id=创建-goroutine>创建 Goroutine<a hidden class=anchor aria-hidden=true href=#创建-goroutine>#</a></h2><p>创建 Goroutine 很简单，只需要在函数前增加一个 <code>go</code> 关键字，格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>fun1</span>(<span style=color:#f92672>...</span>)  
</span></span></code></pre></div><p>也支持匿名函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>...</span>){  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}(<span style=color:#f92672>...</span>)  
</span></span></code></pre></div><ul><li><code>go</code> 关键字后的函数可以写返回值，但无效。因为 Goroutine 是异步的，所以没法接受。</li></ul><p>下来看一个完整的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrintA</span>()  {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;A&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>PrintA</span>()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>看上面 <code>main</code> 函数只有两行：</p><ul><li>第一行：创建一个 Goroutine，异步打印“A”字符串。</li><li>第二行：打印 “main” 字符串。</li></ul><p>现在先停留一会，想想执行该代码后，输出结果是啥。</p><p>结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>main</span>  
</span></span></code></pre></div><p>你没看错，没有输出“A”字符串。</p><p>因为 <code>go PrintA()</code> 创建的 Goroutine 它是异步执行，<code>main</code> 函数执行完退出程序时，也不会管它。所以下来看如何让 <code>main</code> 函数等待 Goroutine 执行完。</p><p><strong>方法一</strong>：使用 <code>time.Sleep</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>PrintA</span>()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>A</span>  
</span></span></code></pre></div><p><code>main</code> 函数退出前让等一会。</p><p><strong>方法二</strong>：使用空的 <code>select</code> 语句，非空的 <code>select</code> 用法会配合通道一块讲解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>PrintA</span>()  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>select</span> {}  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>A</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fatal</span> <span style=color:#66d9ef>error</span>: <span style=color:#a6e22e>all</span> <span style=color:#a6e22e>goroutines</span> <span style=color:#a6e22e>are</span> <span style=color:#a6e22e>asleep</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>deadlock</span>!  
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>  
</span></span></code></pre></div><p>"A" 字符串是输出了，但程序也出现异常了。</p><p>原因是，当程序中存在运行的 Goroutine，<code>select{}</code> 就会一直等待，如果 Goroutine 都执行结束了，没有什么可等待的了，就会抛出异常。</p><p>在真实项目中，出现异常自然不对，那 <code>select{}</code> 使用场景是啥，例如：</p><ul><li>爬虫项目，创建了 Goroutine，需要一直爬取数据，不需要停止。</li></ul><p><strong>方法三</strong>：使用 <code>WaitGroup</code> 类型等待 Goroutine 结束，项目中常常使用，完整例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrintA</span>()  {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;A&#34;</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>PrintA</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li>声明 <code>WaitGroup</code> 类型变量 <code>wg</code>，使用时无需初始化。</li><li><code>wg.Add(1)</code> 表示需要等待一个 Goroutine，如果有两个，使用 <code>Add(2)</code>。</li><li>当一个 Goroutine 运行完后使用 <code>wg.Done()</code> 通知。</li><li><code>wg.Wait()</code> 等待 Goroutine 执行完。</li></ul><h2 id=控制并发数>控制并发数<a hidden class=anchor aria-hidden=true href=#控制并发数>#</a></h2><p>Go 语言中可以控制使用 CPU 的核心数量，从 Go1.5 版本开始，默认设置为 CPU 的总核心数。如果想自定义设置，使用如下函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#a6e22e>num</span>)  
</span></span></code></pre></div><p>num 如果大于 CPU 的核心数，也是允许的，Go 语言调度器会将很多的 Goroutine 分配到不同的处理器上。</p><h2 id=什么是通道>什么是通道<a hidden class=anchor aria-hidden=true href=#什么是通道>#</a></h2><p>现在明白了怎么创建 Goroutine 后，下一步就要知道它们之间要如何通信。</p><p><img loading=lazy src=/images/20231207161257.webp alt=20231207161257.webp></p><p>Goroutine 通信使用“通道 (channel)”，如果 Goroutine1 想发送数据给 Goroutine2，就把数据放到通道里，Goroutine2 直接从通道里拿就行，反过来也是一样。</p><p>在给通道放数据时，也可以指定通道放置的数据类型。</p><h2 id=创建通道>创建通道<a hidden class=anchor aria-hidden=true href=#创建通道>#</a></h2><p>创建通道时，分为无缓冲和有缓冲两种。</p><h3 id=1-无缓冲>1. 无缓冲<a hidden class=anchor aria-hidden=true href=#1-无缓冲>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>strChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)  
</span></span></code></pre></div><p>定义了一个存储数据类型为 <code>string</code> 的无缓冲通道，如果想存储任意类型，那数据类型设置为空接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>allChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>interface</span>{})  
</span></span></code></pre></div><p>创建好了通道，下来就要给通道里放数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>strChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>strChan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;老苗&#34;</span>  
</span></span></code></pre></div><p>使用 "&lt;-" 操作符链接数据，表示将“老苗”字符串送入 <code>strChan</code> 通道变量。</p><p>但这样放数据是会报错的，因为 <code>strChan</code> 变量是<strong>无缓冲通道，放入数据时 main 函数会一直等待</strong>，因此会造成死锁。</p><p>如果想解决死锁情况，就要保证有地方在异步读通道，因此需要创建一个 Goroutine 来负责。</p><p>例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// concurrency/channel/main.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>strChan</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>strChan</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>strChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>strChan</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>strChan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;老苗&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>老苗</span>  
</span></span></code></pre></div><ul><li><code>Read</code> 函数负责读取通道数据，并打印。</li><li>通道是引用类型，因此传递时无需使用指针。</li><li><code>&lt;-strChan</code> 表示从通道里拿数据，如果通道里没有数据它会进行阻塞。</li><li><code>wg.Wait()</code> 等待 <code>Read</code> 异步函数执行完。</li></ul><h3 id=2-有缓冲>2. 有缓冲<a hidden class=anchor aria-hidden=true href=#2-有缓冲>#</a></h3><p>读了上面就会了解到，对于无缓冲通道，它会产生阻塞。为了不让阻塞，必须创建一个 Goroutine 负责从通道读取才行。</p><p>而有缓冲的通道，会有缓冲的余地，具体来看看。</p><p>创建缓冲通道，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>bufferChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>3</span>)  
</span></span></code></pre></div><ul><li>创建了一个存储数据类型为 string 的通道。</li><li>可以缓冲 3 个数据，即给通道送入 3 个数据不会进行阻塞。</li></ul><p>测试如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// concurrency/bufferchannel/main.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufferChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>3</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufferChan</span><span style=color:#f92672>&lt;-</span><span style=color:#e6db74>&#34;a&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufferChan</span><span style=color:#f92672>&lt;-</span><span style=color:#e6db74>&#34;b&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufferChan</span><span style=color:#f92672>&lt;-</span><span style=color:#e6db74>&#34;c&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>bufferChan</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>a</span>  
</span></span></code></pre></div><ul><li>给 <code>bufferChan</code> 变量存入 3 个字符串。</li><li>存入 3 个数据时不会阻塞，当存入数量超过 3 时，就需要 Goroutine 异步读取。</li></ul><p>缓冲通道何时使用，例如：</p><p>爬虫数据，第 1 个 Goroutine 负责爬取数据，第 2 个 Goroutine 负责处理和存储数据。 当第 1 个的处理速度大于第 2 个时，可以使用缓冲通道暂存起来。</p><p>暂存起来后，第 1 个 Goroutine 就可以继续爬取，而不像无缓冲通道，放入数据时会阻塞，直到通道数据被读出，才能进行。</p><p>为了加深印象，再来一张图：</p><p><img loading=lazy src=/images/20231207161264.webp alt=20231207161264.webp></p><p>图解：</p><ul><li><code>bufferChan</code> 长度为 3 的缓冲通道，并且已存入 2 个数据。</li><li>看图中的两个箭头，箭头在 <code>bufferChan</code> 右边，表示存，左边表示取。</li><li>按照先入先出规则存取。</li></ul><h2 id=单向通道>单向通道<a hidden class=anchor aria-hidden=true href=#单向通道>#</a></h2><p>现在知道了如何创建一个双向通道，双向通道指的就是即可以存，又可以取。</p><p>那单向通道创建如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>readChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>writeChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>string</span>)  
</span></span></code></pre></div><ul><li><code>readChan</code> 只能读取数据。</li><li><code>writeChan</code> 只能存取数据。</li></ul><p>但这样创建的通道是无法传递数据的，为什么？</p><p>因为，如果只能读的通道，没法存数据，那我存了个寂寞。而存的通道，我数据拿不出来，又有何用。</p><p>现在看看如何正确使用单向通道的例子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// concurrency/onechannel/main.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>  
</span></span><span style=display:flex><span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 写通道  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span><span style=color:#f92672>&lt;-</span><span style=color:#ae81ff>520</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 读通道  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>data</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dataChan</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>dataChan</span>)  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>dataChan</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>520</span>  
</span></span></code></pre></div><ul><li>创建了两个 Goroutine，<code>read</code> 函数负责只读，<code>write</code> 函数负责只写。</li><li>通道传递时，将双向通道转化为单向通道。</li></ul><h2 id=遍历通道>遍历通道<a hidden class=anchor aria-hidden=true href=#遍历通道>#</a></h2><p>在实际项目中，通道里会产生大量的数据，这时候就要循环的从通道里读取。</p><p>现在改写单向通道写入数据的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>data</span><span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>i</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>这段代码是给通道里循环写入数字。</p><p>下来使用两种方式循环读取通道数据。</p><h3 id=1-死循环>1. 死循环<a hidden class=anchor aria-hidden=true href=#1-死循环>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>data</span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>使用死循环读取数据，但这个有个问题，什么时候退出 for 循环？</p><p><code>read</code> 函数在读取通道时是不知道数据写入完了，如果读取不到数据，它会一直阻塞，因此，如果写数据完成时，需要使用 <code>close</code> 函数关闭通道。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	close(<span style=color:#a6e22e>data</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>关闭后，读取通道时也需要检测判断。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>d</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>data</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li><code>ok</code> 变量为 false 时，表示通道已关闭。</li><li>关闭通道后，<code>ok</code> 变量不会立马变成 false，而是等已放入通道的数据都读取完。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;a&#34;</span>  
</span></span><span style=display:flex><span>close(<span style=color:#a6e22e>ch</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>ok</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val1</span>, <span style=color:#a6e22e>ok1</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>val1</span>, <span style=color:#a6e22e>ok1</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>true</span>  
</span></span><span style=display:flex><span> <span style=color:#66d9ef>false</span>  
</span></span></code></pre></div><h3 id=2-for-range>2. for-range<a hidden class=anchor aria-hidden=true href=#2-for-range>#</a></h3><p>也可以使用 for-range 语句读取通道，这比死循环使用起来简单一点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)  {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span>{  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li>如果想退出 for-range 语句，也需要关闭通道。</li><li>如果关闭通道后，不需要增加 ok 判断，等通道数据读取完，自行会退出。</li></ul><h2 id=通道函数>通道函数<a hidden class=anchor aria-hidden=true href=#通道函数>#</a></h2><p>使用 <code>len</code> 函数获取通道里还有多少个消息未读，<code>cap</code> 函数获取通道的缓冲大小</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ch</span><span style=color:#f92672>&lt;-</span><span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>ch</span>))  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(cap(<span style=color:#a6e22e>ch</span>))  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  
</span></span></code></pre></div><h2 id=select-语句>select 语句<a hidden class=anchor aria-hidden=true href=#select-语句>#</a></h2><p>上面已经知道了空 <code>select</code> 语句的作用，现在看看非空 <code>select</code> 的用法。</p><p><code>select</code> 语句 和 <code>switch</code> 语句类似，它也有 <code>case</code> 分支，也有 <code>default</code> 分支，但 <code>select</code> 语句的不同点有两个：</p><ul><li><code>case</code> 分支只能是“读通道”或“写通道”，如果读写成功，即不阻塞，则 <code>case</code> 分支就满足。</li><li><code>fallthrough</code> 关键字不能使用。</li></ul><h3 id=1-无-default-分支>1. 无 default 分支<a hidden class=anchor aria-hidden=true href=#1-无-default-分支>#</a></h3><p><code>select</code> 语句会在 <code>case</code> 分支中选择一个可读写成功的通道。</p><p>正确例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// concurrency/select/main.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ch1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ch2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ch1</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>select</span> {  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span>:  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ch1通道&#34;</span>, <span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch2</span>:  
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ch2通道&#34;</span>, <span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ch1</span><span style=color:#960050;background-color:#1e0010>通道</span> <span style=color:#ae81ff>1</span>  
</span></span></code></pre></div><ul><li><code>ch1</code> 通道有数据，因此进入了第一个 <code>case</code> 分支。</li><li>这里展示了读通道，也可以给通道写数据，例：<code>case ch2&lt;-2</code>。</li><li>如果删除 <code>ch1 &lt;- 1</code> ，<code>select</code> 语句会在 main 函数中一直等待，因此会造成死锁。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fatal</span> <span style=color:#66d9ef>error</span>: <span style=color:#a6e22e>all</span> <span style=color:#a6e22e>goroutines</span> <span style=color:#a6e22e>are</span> <span style=color:#a6e22e>asleep</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>deadlock</span>!  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#66d9ef>select</span>]:  
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>C</span>:<span style=color:#f92672>/</span><span style=color:#a6e22e>workspace</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>gobasic</span><span style=color:#f92672>/</span><span style=color:#a6e22e>cocurrency</span><span style=color:#f92672>/</span><span style=color:#66d9ef>select</span><span style=color:#f92672>/</span><span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0xe7</span>  
</span></span></code></pre></div><h3 id=2-有-default-分支>2. 有 default 分支<a hidden class=anchor aria-hidden=true href=#2-有-default-分支>#</a></h3><p>为了防止 <code>select</code> 语句出现死锁，可以增加 <code>default</code> 分支。意思就是，当没有一个 <code>case</code> 分支可以进行通道读写，那就走 <code>default</code> 分支。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ch1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ch2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>select</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span>:  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ch1通道&#34;</span>, <span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch2</span>:  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ch2通道&#34;</span>, <span style=color:#a6e22e>v</span>)  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;没有可读写通道&#34;</span>)  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>没有可读写通道</span>  
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>这节课很关键，也是很容易出现问题的地方，我再针对重点的重点强调一下：</p><ul><li>在函数调用前增加 <code>go</code> 关键字，表示创建 Goroutine。</li><li>执行 Goroutine 不会同步等待，常用的使用 <code>WaitGroup</code> 类型处理。</li><li>Goroutine 的通信使用通道传输。</li><li>无缓冲的通道，不要进行同步读写，不然会阻塞。</li></ul><p>最后，再揣摩一句话，<strong>不要用共享内存来通信，要用通信来共享内存。</strong></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/go-big-small/><span class=title>« 上一页</span><br><span>快速了解 “小字端” 和 “大字端” 及 Go 语言中的使用</span></a>
<a class=next href=https://www.printlove.cn/golang-format/><span class=title>下一页 »</span><br><span>Go基础系列：17. 详解 20 个占位符</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：18. 并发 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a18.%20%e5%b9%b6%e5%8f%91&amp;url=https%3a%2f%2fwww.printlove.cn%2fgolang-concurrency%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：18. 并发 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a18.%20%e5%b9%b6%e5%8f%91"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>