<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：10. 函数 | PrintLove</title><meta name=keywords content="Go,函数"><meta name=description content="一文搞懂 Go 语言中的函数，系统整理了 15 个内置函数"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.printlove.cn/golang-func/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：10. 函数"><meta property="og:description" content="一文搞懂 Go 语言中的函数，系统整理了 15 个内置函数"><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/golang-func/"><meta property="og:image" content="https://images.unsplash.com/photo-1519713319223-70371c5c5aeb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw0Nnx8ZnVuY3Rpb258ZW58MHwwfHx8MTcwMzMwMjIwNHww&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-06T17:15:56+08:00"><meta property="article:modified_time" content="2021-08-06T17:15:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1519713319223-70371c5c5aeb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw0Nnx8ZnVuY3Rpb258ZW58MHwwfHx8MTcwMzMwMjIwNHww&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：10. 函数"><meta name=twitter:description content="一文搞懂 Go 语言中的函数，系统整理了 15 个内置函数"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：10. 函数","item":"https://www.printlove.cn/golang-func/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：10. 函数","name":"Go基础系列：10. 函数","description":"一文搞懂 Go 语言中的函数，系统整理了 15 个内置函数","keywords":["Go","函数"],"articleBody":"学到什么 如何调用函数？ 如何构造函数？ 函数如何返回多个值？ 如何构造匿名函数？ 如何传递函数？ 内置函数有哪些？ 介绍 函数是基本的代码块，它负责将一个复杂问题分解为不同的函数提供调用与复用。\n编写函数时，无需关注顺序，因为 Go 语言是编译型的。\n在 Go 语言中有三种函数类型：\n基本格式：有命名的函数，直接调用完事。 匿名函数：没有名字的函数。 结构体携带的函数：也可以称之为方法，后续结构体再展开讲解。 基本格式 func Fun1(arg1 T, arg2 T) T { ... return r1 } Fun1 为自定义的函数名称。 arg1 和 arg2 为自定义参数名称，声明了两个参数，可以再增加。 T 代表 Go 语言中的任意类型，使用时替换成 int、string、slice 等等类型。 小括号后紧跟函数返回值类型。 return 为函数返回的关键字，携带要返回的值，函数内之后的逻辑将不会执行。 函数体的第一个花括号必须紧跟在函数后。 举例：\n// 计算两个数之和并且返回 func AddNum(n1 int, n2 int) int { return n1 + n2 } 函数也可以没有返回值，这个时候就无需 return 关键字，例如： main() 入口函数、 init() 初始化函数。\n当函数体内出现了 panic 函数，用于抛出异常，这时如果定义了返回类型， return 关键字就可以选择省略。\n返回多个值 Go 语言函数中有个特点，可以多个值返回。在声明返回值类型时，可以不指定名称，也可以指定名称，啥意思呢，往下看。\n1. 无名称 func Fun1(arg1 T, arg2 T) (T, T) { ... return r1, r2 } 和“基本格式”的不同点：\n当需要返回至少两个值时，返回类型需要用小括号包裹，以逗号分隔。 使用 return 携带多个返回值。 2. 有名称 func Fun1(arg1 T, arg2 T) (n1 T, n2 T) { ... return } 返回值类型指定了名称后，在 return 返回时，可以不带值，当然也可以都带上。 当有了名称，即使是 1 个返回类型，也需要用小括号包裹。 为什么有了名称 return 就不用携带值呢？\n因为相当于在返回时，初始化好了返回值，例如上面的格式中 n1 和 n2 就是初始化的两个变量，在函数运算中，只要将返回结果存入 n1 和 n2 中，不存就按照初始化返回，当然也可以 return 携带值。\n函数调用 构造好一个函数后，如何调用，格式如下：\nr1, r2 := Fun1(param1, param2) 调用时传递了两个参数，返回时接受两个返回值。\n如果接受多个值时，某个值我不想使用时，是不能搁置在那的，不然编译器会报错，需要使用下划线 \"_\" 替代，表示我不用。\nr1, _ := Fun1(param1, param2) 匿名函数 匿名函数就是在构造函数时，函数没有名称，想调用时，需要把匿名函数赋值给一个变量，或者在构造时直接调用。\n1. 赋值给变量 fun1 := func (arg1 T, arg2 T) T { ... return r1 } 赋值后， fun1 就是一个函数类型的变量， 调用格式：fun1(param1, param2) 。\n2. 构造时调用 func (arg1 T, arg2 T) T { ... return r1 }(param1, param2) 在构造函数时，花括号后紧跟参数传递 (param1, param2)，不需要赋值给一个变量，直接构造后马上调用。\n传递函数 在 Go 语言中，函数是“一等公民”，它和 int 、string 等等，都是一个级别，可以作为参数进行传递。\n举例：\n// function/deliver.go package main // callback 是一个函数类型参数 func Calc(callback func(n1 int, n2 int) int) int { x, y := 3, 4 return callback(x, y) } // 计算两数之积 func Mul(n1 int, n2 int) int { return n1 * n2 } func main() { // 第一个：传递一个匿名函数 Calc(func(n1 int, n2 int) int { return n1 + n2 }) // 第二个：传递一个定义好的函数 Calc(Mul) } 分别演示了两种函数的传递方式，第一个匿名函数计算两数之和，第二个用定义好的函数计算两数之积。当然传递函数不止是通过参数，也可以是函数返回值、切片元素保存、map 值保存等等。\n声明函数类型 声明函数类型，意思就是可以自定义一个函数类型，给这个函数取一个别名，像例如 int 一样很方便的去声明变量或者参数类型。\ntype CallbackFunc func(n1 int, n2 int) int 现在自定义了一个名为 CallbackFunc 的函数类型，下来看如何使用：\nfunc Calc(callback CallbackFunc) int { ... } Calc 函数有一个函数参数，这个参数的类型名称为 CallbackFunc 。\n函数参数 1. 参数类型省略 在声明函数参数时，有时候会遇到连续声明多个相同类型，这个时候，就可以只保留一个类型名称。\n// 没精简的 func Fun1(arg1 string, arg2 int, arg3 int) // 精简后 func Fun1(arg1 string, arg2, arg3 int) 精简后， arg2 参数后省略了 int，这样就和它后面的参数类型一致。\n2. 值传递与引用传递 我们先定下参数称呼，函数调用时传递的参数称为实参，构造函数时的参数称为形参。\n在 Go 语言中，切片（slice）、map、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递，在函数内修改形参是会改变实参的值。\n对于切片，有种情况会打破引用传递这个规律，具体可以看看 《内置集合 - 切片》 这篇文章。\n对于其它剩下的类型，默认都是值传递，函数接收到的形参只是副本，函数内对形参的更改是不会影响到实参的。\n如果希望更改实参的值，可以传递指针，在实参前增加“\u0026”符号，表示取实参的地址，例如： Fun1(\u0026param) 。\n3. 变长参数 当构造函数时，函数的最后一个参数是 ...T 形式时，称为变长参数，它可以接受至少 0 个数据。\n// 一个固定参数，一个变长参数 // nums 实际是一个切片 func Func1(str string, nums ...int) { ... } 调用例子如下：\n// 没传递变长参数 Func1(\"miao\") // 给变长参数传递不同数量的值 Func1(\"miao\", 1) Func1(\"miao\", 1, 2) 当把一个切片类型传递给可变参数时，在切片后跟着 ... 三个点，传递给变长参数，表示将切片元素展开。\nnums := []int{1, 2, 3} Func1(\"miao\", nums...) 内置函数 在 Go 语言中，有一些函数无需导入任何包就可以使用，下来对这些函数简要说明一下。\n总共 15 个内置函数，如下：\nmake：为切片，map、通道类型分配内存并初始化对象。 len：计算数组、切片、map、通道的长度。 cap：计算数组、切片、通道的容量。 delete：删除 map 中对应的键值对。 append：将数据添加到切片的末尾。 copy：将原切片的数据复制到新切片中。 new：除切片、map、通道类型以外的类型分配内存并初始化对象，返回的类型为指针。 complex：生成一个复数。 real：获取复数的实部。 imag：获取复数的虚部 print：将信息打印到标准输出，没有换行。 println：将信息打印到标准输出并换行。 close：关闭通道。 panic：触发程序异常。 recover：捕捉 panic 的异常信息。 总结 本篇我对 Go 语言中的函数进行了系统的讲解，也列举了 15 个内置函数。对于内置函数的使用，有的在前面文章使用过，有的还没有，先做一个整体的了解，等到了用的时候再详查。\n","wordCount":"394","inLanguage":"zh","image":"https://images.unsplash.com/photo-1519713319223-70371c5c5aeb?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw0Nnx8ZnVuY3Rpb258ZW58MHwwfHx8MTcwMzMwMjIwNHww\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-08-06T17:15:56+08:00","dateModified":"2021-08-06T17:15:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/golang-func/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：10. 函数</h1><div class=post-meta><span title='2021-08-06 17:15:56 +0800 CST'>2021-08-06</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a10.%20%e5%87%bd%e6%95%b0.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#介绍>介绍</a></li><li><a href=#基本格式>基本格式</a></li><li><a href=#返回多个值>返回多个值</a><ul><li><a href=#1-无名称>1. 无名称</a></li><li><a href=#2-有名称>2. 有名称</a></li></ul></li><li><a href=#函数调用>函数调用</a></li><li><a href=#匿名函数>匿名函数</a><ul><li><a href=#1-赋值给变量>1. 赋值给变量</a></li><li><a href=#2-构造时调用>2. 构造时调用</a></li></ul></li><li><a href=#传递函数>传递函数</a></li><li><a href=#声明函数类型>声明函数类型</a></li><li><a href=#函数参数>函数参数</a><ul><li><a href=#1-参数类型省略>1. 参数类型省略</a></li><li><a href=#2-值传递与引用传递>2. 值传递与引用传递</a></li><li><a href=#3-变长参数>3. 变长参数</a></li></ul></li><li><a href=#内置函数>内置函数</a></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>如何调用函数？</li><li>如何构造函数？</li><li>函数如何返回多个值？</li><li>如何构造匿名函数？</li><li>如何传递函数？</li><li>内置函数有哪些？</li></ol><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>函数是基本的代码块，它负责将一个复杂问题分解为不同的函数提供调用与复用。</p><p><strong>编写函数时，无需关注顺序</strong>，因为 Go 语言是编译型的。</p><p>在 Go 语言中有三种函数类型：</p><ul><li>基本格式：有命名的函数，直接调用完事。</li><li>匿名函数：没有名字的函数。</li><li>结构体携带的函数：也可以称之为方法，后续结构体再展开讲解。</li></ul><h2 id=基本格式>基本格式<a hidden class=anchor aria-hidden=true href=#基本格式>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>arg1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r1</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li><code>Fun1</code> 为自定义的函数名称。</li><li><code>arg1</code> 和 <code>arg2</code> 为自定义参数名称，声明了两个参数，可以再增加。</li><li><code>T</code> 代表 Go 语言中的任意类型，使用时替换成 int、string、slice 等等类型。</li><li>小括号后紧跟函数返回值类型。</li><li><code>return</code> 为函数返回的关键字，携带要返回的值，函数内之后的逻辑将不会执行。</li><li>函数体的第一个花括号必须紧跟在函数后。</li></ul><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 计算两个数之和并且返回  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddNum</span>(<span style=color:#a6e22e>n1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>n2</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>函数也可以没有返回值，这个时候就无需 <code>return</code> 关键字，例如： <code>main()</code> 入口函数、 <code>init()</code> 初始化函数。</p><p>当函数体内出现了 <code>panic</code> 函数，用于抛出异常，这时如果定义了返回类型， <code>return</code> 关键字就可以选择省略。</p><h2 id=返回多个值>返回多个值<a hidden class=anchor aria-hidden=true href=#返回多个值>#</a></h2><p>Go 语言函数中有个特点，可以多个值返回。在声明返回值类型时，可以不指定名称，也可以指定名称，啥意思呢，往下看。</p><h3 id=1-无名称>1. 无名称<a hidden class=anchor aria-hidden=true href=#1-无名称>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>arg1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#a6e22e>T</span>) (<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>T</span>) {  
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>和“基本格式”的不同点：</p><ul><li>当需要返回至少两个值时，返回类型需要用小括号包裹，以逗号分隔。</li><li>使用 <code>return</code> 携带多个返回值。</li></ul><h3 id=2-有名称>2. 有名称<a hidden class=anchor aria-hidden=true href=#2-有名称>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>arg1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#a6e22e>T</span>) (<span style=color:#a6e22e>n1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>n2</span> <span style=color:#a6e22e>T</span>) {  
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li>返回值类型指定了名称后，在 <code>return</code> 返回时，可以不带值，当然也可以都带上。</li><li>当有了名称，即使是 1 个返回类型，也需要用小括号包裹。</li></ul><p>为什么有了名称 <code>return</code> 就不用携带值呢？</p><p>因为相当于在返回时，初始化好了返回值，例如上面的格式中 <code>n1</code> 和 <code>n2</code> 就是初始化的两个变量，在函数运算中，只要将返回结果存入 <code>n1</code> 和 <code>n2</code> 中，不存就按照初始化返回，当然也可以 <code>return</code> 携带值。</p><h2 id=函数调用>函数调用<a hidden class=anchor aria-hidden=true href=#函数调用>#</a></h2><p>构造好一个函数后，如何调用，格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>param1</span>, <span style=color:#a6e22e>param2</span>)  
</span></span></code></pre></div><p>调用时传递了两个参数，返回时接受两个返回值。</p><p>如果接受多个值时，某个值我不想使用时，是不能搁置在那的，不然编译器会报错，需要使用下划线 "_" 替代，表示我不用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>param1</span>, <span style=color:#a6e22e>param2</span>)  
</span></span></code></pre></div><h2 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h2><p>匿名函数就是在构造函数时，函数没有名称，想调用时，需要把匿名函数赋值给一个变量，或者在构造时直接调用。</p><h3 id=1-赋值给变量>1. 赋值给变量<a hidden class=anchor aria-hidden=true href=#1-赋值给变量>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fun1</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arg1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r1</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>赋值后， <code>fun1</code> 就是一个函数类型的变量， 调用格式：<code>fun1(param1, param2)</code> 。</p><h3 id=2-构造时调用>2. 构造时调用<a hidden class=anchor aria-hidden=true href=#2-构造时调用>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arg1</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {  
</span></span><span style=display:flex><span>		<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r1</span>  
</span></span><span style=display:flex><span>}(<span style=color:#a6e22e>param1</span>, <span style=color:#a6e22e>param2</span>)  
</span></span></code></pre></div><p>在构造函数时，花括号后紧跟参数传递 <code>(param1, param2)</code>，不需要赋值给一个变量，直接构造后马上调用。</p><h2 id=传递函数>传递函数<a hidden class=anchor aria-hidden=true href=#传递函数>#</a></h2><p>在 Go 语言中，<strong>函数是“一等公民”</strong>，它和 int 、string 等等，都是一个级别，可以作为参数进行传递。</p><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// function/deliver.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// callback 是一个函数类型参数  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Calc</span>(<span style=color:#a6e22e>callback</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 计算两数之积  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Mul</span>(<span style=color:#a6e22e>n1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>n2</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 第一个：传递一个匿名函数  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Calc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>n2</span>  
</span></span><span style=display:flex><span>	})  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 第二个：传递一个定义好的函数  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Calc</span>(<span style=color:#a6e22e>Mul</span>)  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>分别演示了两种函数的传递方式，第一个匿名函数计算两数之和，第二个用定义好的函数计算两数之积。当然传递函数不止是通过参数，也可以是函数返回值、切片元素保存、map 值保存等等。</p><h2 id=声明函数类型>声明函数类型<a hidden class=anchor aria-hidden=true href=#声明函数类型>#</a></h2><p>声明函数类型，意思就是可以自定义一个函数类型，给这个函数取一个别名，像例如 <code>int</code> 一样很方便的去声明变量或者参数类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CallbackFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>  
</span></span></code></pre></div><p>现在自定义了一个名为 <code>CallbackFunc</code> 的函数类型，下来看如何使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Calc</span>(<span style=color:#a6e22e>callback</span> <span style=color:#a6e22e>CallbackFunc</span>) <span style=color:#66d9ef>int</span> {  
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p><code>Calc</code> 函数有一个函数参数，这个参数的类型名称为 <code>CallbackFunc</code> 。</p><h2 id=函数参数>函数参数<a hidden class=anchor aria-hidden=true href=#函数参数>#</a></h2><h3 id=1-参数类型省略>1. 参数类型省略<a hidden class=anchor aria-hidden=true href=#1-参数类型省略>#</a></h3><p>在声明函数参数时，有时候会遇到连续声明多个相同类型，这个时候，就可以只保留一个类型名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 没精简的  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>arg1</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>arg2</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>arg3</span> <span style=color:#66d9ef>int</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 精简后  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fun1</span>(<span style=color:#a6e22e>arg1</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>arg2</span>, <span style=color:#a6e22e>arg3</span> <span style=color:#66d9ef>int</span>)  
</span></span></code></pre></div><p>精简后， <code>arg2</code> 参数后省略了 int，这样就和它后面的参数类型一致。</p><h3 id=2-值传递与引用传递>2. 值传递与引用传递<a hidden class=anchor aria-hidden=true href=#2-值传递与引用传递>#</a></h3><p>我们先定下参数称呼，函数调用时传递的参数称为实参，构造函数时的参数称为形参。</p><p>在 Go 语言中，切片（slice）、map、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递，在函数内修改形参是会改变实参的值。</p><p>对于切片，有种情况会打破引用传递这个规律，具体可以看看 <a href=/golang-slice/>《内置集合 - 切片》</a> 这篇文章。</p><p>对于其它剩下的类型，默认都是值传递，函数接收到的形参只是副本，函数内对形参的更改是不会影响到实参的。</p><p>如果希望更改实参的值，可以传递指针，在实参前增加“&”符号，表示取实参的地址，例如： <code>Fun1(&amp;param)</code> 。</p><h3 id=3-变长参数>3. 变长参数<a hidden class=anchor aria-hidden=true href=#3-变长参数>#</a></h3><p>当构造函数时，函数的最后一个参数是 <code>...T</code> 形式时，称为变长参数，它可以接受至少 0 个数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 一个固定参数，一个变长参数  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// nums 实际是一个切片  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Func1</span>(<span style=color:#a6e22e>str</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>nums</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>int</span>) {  
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>调用例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 没传递变长参数  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Func1</span>(<span style=color:#e6db74>&#34;miao&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 给变长参数传递不同数量的值  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Func1</span>(<span style=color:#e6db74>&#34;miao&#34;</span>, <span style=color:#ae81ff>1</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>Func1</span>(<span style=color:#e6db74>&#34;miao&#34;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)  
</span></span></code></pre></div><p>当把一个切片类型传递给可变参数时，在切片后跟着 <code>...</code> 三个点，传递给变长参数，表示将切片元素展开。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>Func1</span>(<span style=color:#e6db74>&#34;miao&#34;</span>, <span style=color:#a6e22e>nums</span><span style=color:#f92672>...</span>)  
</span></span></code></pre></div><h2 id=内置函数>内置函数<a hidden class=anchor aria-hidden=true href=#内置函数>#</a></h2><p>在 Go 语言中，有一些函数无需导入任何包就可以使用，下来对这些函数简要说明一下。</p><p>总共 15 个内置函数，如下：</p><ol><li>make：为切片，map、通道类型分配内存并初始化对象。</li><li>len：计算数组、切片、map、通道的长度。</li><li>cap：计算数组、切片、通道的容量。</li><li>delete：删除 map 中对应的键值对。</li><li>append：将数据添加到切片的末尾。</li><li>copy：将原切片的数据复制到新切片中。</li><li>new：除切片、map、通道类型以外的类型分配内存并初始化对象，返回的类型为指针。</li><li>complex：生成一个复数。</li><li>real：获取复数的实部。</li><li>imag：获取复数的虚部</li><li>print：将信息打印到标准输出，没有换行。</li><li>println：将信息打印到标准输出并换行。</li><li>close：关闭通道。</li><li>panic：触发程序异常。</li><li>recover：捕捉 panic 的异常信息。</li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本篇我对 Go 语言中的函数进行了系统的讲解，也列举了 15 个内置函数。对于内置函数的使用，有的在前面文章使用过，有的还没有，先做一个整体的了解，等到了用的时候再详查。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/secret-camera/><span class=title>« 上一页</span><br><span>中国打击隐藏摄像机和秘密拍摄</span></a>
<a class=next href=https://www.printlove.cn/henan-flood/><span class=title>下一页 »</span><br><span>BBC如何报道河南洪灾？</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：10. 函数 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a10.%20%e5%87%bd%e6%95%b0&amp;url=https%3a%2f%2fwww.printlove.cn%2fgolang-func%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：10. 函数 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a10.%20%e5%87%bd%e6%95%b0"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>