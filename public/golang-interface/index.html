<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：15. 接口 | PrintLove</title><meta name=keywords content="program_golang"><meta name=description content="什么是接口？如何定义接口？如何使用接口？如何嵌入接口？接口与接口之间如何赋值？如何推断接口的实际类型？如何使用空接口？"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.printlove.cn/golang-interface/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：15. 接口"><meta property="og:description" content="什么是接口？如何定义接口？如何使用接口？如何嵌入接口？接口与接口之间如何赋值？如何推断接口的实际类型？如何使用空接口？"><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/golang-interface/"><meta property="og:image" content="https://images.unsplash.com/photo-1544399801-26566b814c16?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw1MHx8aW50ZXJmYWNlfGVufDB8MHx8fDE3MDMxNDAxNjB8MA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-18T17:51:56+08:00"><meta property="article:modified_time" content="2021-09-18T17:51:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1544399801-26566b814c16?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw1MHx8aW50ZXJmYWNlfGVufDB8MHx8fDE3MDMxNDAxNjB8MA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：15. 接口"><meta name=twitter:description content="什么是接口？如何定义接口？如何使用接口？如何嵌入接口？接口与接口之间如何赋值？如何推断接口的实际类型？如何使用空接口？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：15. 接口","item":"https://www.printlove.cn/golang-interface/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：15. 接口","name":"Go基础系列：15. 接口","description":"什么是接口？如何定义接口？如何使用接口？如何嵌入接口？接口与接口之间如何赋值？如何推断接口的实际类型？如何使用空接口？","keywords":["program_golang"],"articleBody":"学到什么 什么是接口？ 如何定义接口？ 如何使用接口？ 如何嵌入接口？ 接口与接口之间如何赋值？ 如何推断接口的实际类型？ 如何使用空接口？ 概念 接口是通过定义抽象方法来约定实现者的规则，概念和其它语言中有点类似，但对于 Go 语言中接口的实现与接口之间耦合性更低，灵活性更高。\n为了通俗的理解接口的概念，我举个例子，\" 假如你受女娲之托让你进行造人的工作，但给你制定了造人的要求，要有吃喝的动作，但具体每个人怎么吃怎么喝那无所谓，只要有了这两个动作就表示你造人成功 \"。\n这个例子中女娲制定的要求就是接口，你按照造人的要求去做就称作接口的实现。\n也不知道讲明白了没，保佑你可以。\n定义 现在定义一个 People 的接口，并定义吃喝两个动作。\ntype People interface { // 可不写参数名：Eat(string) error Eat(thing string) error Drink(thing string) error } Eat 和 Drink 方法不需要具体实现。 方法前不需要 func 关键字。 方法的参数名称和返回名称可以不写。 定义后就可以直接声明一个该接口类型变量。\nvar p People p 变量没有初始化，此时值为 nil 。\n实现接口 接口实现的工作是交给自定义类型的，自定义类型实现了接口所有的方法，就实现接口了。\ntype LaoMiao struct { Name string Age int } func (l LaoMiao) Eat(thing string) error { fmt.Println(\"在公司偷吃\" + thing) return nil } func (l LaoMiao) Drink(thing string) error { fmt.Println(\"在公司偷喝\" + thing) return nil } LaoMiao 实现了 People 接口中的所有方法，就说明实现了该接口。 无需使用其它语言中 implements 关键字显示的去实现。 可同时实现多个接口。 再看张图，可能就更清晰了，如下：\n图中“实现者”都包含了 A 和 B 接口的方法，那它都实现了这两个接口。\n接口的使用 实现了接口之后，就可以将该类型的实例化赋值给接口类型。\nvar p People = LaoMiao{} p.Eat(\"桃子\") // 输出 在公司偷吃桃子 p 为接口类型，实际的实现是 LaoMiao 类型。\n你可能好奇，我为啥不直接调用呢，类似如下：\nm := LaoMiao{} m.Eat(\"桃子\") 上面代码没有使用 People 接口类型，但如果我再定义一个类型去实现 People 接口，好处就体现出来了。\ntype LaoSun struct { Name string Age int } func (l LaoSun) Eat(thing string) error { fmt.Println(\"在车上吃\" + thing) return nil } func (l LaoSun) Drink(thing string) error { fmt.Println(\"在车上喝\" + thing) return nil } 又增加了一个类型去实现，看清楚这个是 LaoSun ，上面的那个类型是 LaoMiao 。\n现在开始想个问题，如果我想调用这两个类型的方法，并且调用的代码只写一遍，该如何做？喘口气，我告诉你，自然是用接口。\n// interface/main.go // ... func Run(p People) { thing1, thing2 := \"桃子\", \"可乐\" p.Eat(thing1) p.Drink(thing2) } func main() { Run(LaoMiao{}) Run(LaoSun{}) } // 输出 在公司偷吃桃子 在公司偷喝可乐 在车上吃桃子 在车上喝可乐 该代码增加了一个 Run 函数，该函数接受的类型为接口类型，main 函数中将两个实现接口的类型传递给函数。\n接收者类型与接口 在上面的代码中所有实现接口的类型接收者都是值类型，例如：\nfunc (l LaoSun) Eat(thing string) error { // ... } 接收者 l 类型为 LaoSun ，如果是指针接收者应该为 *LaoSun 。\n在使用接口类型调用时，接口接受的类型为值类型，例如：\nRun(LaoSun{}) 该函数的参数 LaoSun{} 为值类型，但其实也可以传递指针类型 Run(\u0026LaoSun{}) ，编译器会进行解引用。\n如果接收者为指针类型时，那给接口传值时必须使用指针类型，例如：\ntype GouDan struct { Name string Age int } func (l *GouDan) Eat(thing string) error { fmt.Println(\"你管我吃\" + thing) return nil } func (l *GouDan) Drink(thing string) error { fmt.Println(\"你管我喝\" + thing) return nil } 重新定义了一个类型去实现 People 接口并且方法的接收者为指针类型，如果给接口传递值类型时，编译器会报错。\nRun(GouDan{}) // 输出 cannot use GouDan{} (type GouDan) as type People in argument to Run: GouDan does not implement People (Drink method has pointer receiver) 正确的是，只能传递指针类型。\nRun(\u0026GouDan{}) 或 var sun *LaoSun = \u0026LaoSun{} Run(sun) 接口嵌入 一个接口可以包含另外一个接口，例如：\ntype Student interface { People Study() } 定义了一个 Student 接口，对于学生接口自然也会有吃喝的动作，因此无需重复定义，只需要将 People 接口嵌入就可以。 如果自定义类型想实现 Student 接口，需要将嵌入接口定义的方法和自己所定义的方法都需要实现。 可嵌入多个接口。 接口与接口赋值 在上面的代码中 People 接口被嵌入到了 Student 接口 ，那这个时候，Student 接口类型变量就可以赋值给 People 类型变量。\n例：\nvar stu Student var pl People = stu 如果把 People 类型不被嵌入，而只是让 Student 接口包含其方法，那上面接口与接口赋值也是允许的。\ntype Student interface { Eat(thing string) error Drink(thing string) error Study() } 总结：大接口包含了小接口的方法，那大接口就可以赋值给小接口。\n空接口 空接口表示没有定义任何抽象方法，如下：\ntype Empty interface {} Empty 类型现在就是空的接口，它可以接受任意类型。\nvar str Empty = \"字符串\" var num Empty = 222 平常项目中使用时，为了更简单，其实无需定义空接口，直接使用 interface{} 作为类型。\nvar str interface{} = \"字符串\" var num interface{} = 222 总结一句：所有类型都实现了空接口，即空接口可以接受任意类型变量。\n类型推断 在一个接口变量中，如果想知道该接口变量的具体实现类型是谁就需要使用类型推断。\n1. 接口转实现者 v := var1.(T) T 表示你需要推断的类型。 v 为转化后类型为 T 的变量。 var1 可以为空接口。 例：\nvar people People // 将 People 类型转化为 LaoMiao 值类型 people = LaoMiao{} val := people.(LaoMiao) // 将 People 类型转化为 LaoMiao 指针类型 people = \u0026LaoMiao{} peo := people.(*LaoMiao) 从例子中可以看出，接口变量中存储的类型和推断时的类型必须相同，如果不相同时，编译器会报错。\npeople = LaoMiao{} // 报错 val := people.(*LaoMiao) // 正确 val := people.(LaoMiao) 2. 是否可推断 如果接口变量中存储的实际类型不确定，那就必须进行判断，如果不判断时出现无法推断的情况，编译器就会报错。\nv, ok := var1.(T) 判断其实就是在推断类型时多增加了一个返回值，如果可推断 ok 值为 true，否则为 false 。\npeople = LaoMiao{} val1, ok := people.(*LaoMiao) fmt.Println(ok) val2, ok := people.(LaoMiao) fmt.Println(ok) // 输出 false true 3. type-switch 这个知识点其实在很早之前的 流程控制 一篇中讲过了，我再讲一遍并补充。\nvar data interface{} data = \"111\" // data 是接口类型， .(type) 获取实际类型 // 将实际类型的值赋给 d 变量 switch d := data.(type) { case string: // 进入分支后，d 是 string 类型 fmt.Println(d + \"str\") case int: // 进入分支后， d 是 int 类型 fmt.Println(d + 1) } // 输出 111str 通过 .(type) 获取接口的实际类型，记住这种方式只能用于 switch 语句中，这也是我为什么单独在这块讲解。 不能使用 fallthrough 关键字。 如果只是判断类型，则无需使用 d 变量接受。 总结 Go 语言的接口知识点就讲完了，很重要，务必要掌握清楚。那现在问问你知道接口的实现精髓是啥吗？\n我总结下，只要实现了其方法就实现了接口，实现的方法如果满足了多个接口，那就都实现。\n","wordCount":"538","inLanguage":"zh","image":"https://images.unsplash.com/photo-1544399801-26566b814c16?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw1MHx8aW50ZXJmYWNlfGVufDB8MHx8fDE3MDMxNDAxNjB8MA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-09-18T17:51:56+08:00","dateModified":"2021-09-18T17:51:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/golang-interface/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：15. 接口</h1><div class=post-meta><span title='2021-09-18 17:51:56 +0800 CST'>2021-09-18</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a15.%e6%8e%a5%e5%8f%a3.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li></ul><ul><li><a href=#定义>定义</a></li><li><a href=#实现接口>实现接口</a></li><li><a href=#接口的使用>接口的使用</a><ul><li><a href=#接收者类型与接口>接收者类型与接口</a></li></ul></li><li><a href=#接口嵌入>接口嵌入</a><ul><li><a href=#接口与接口赋值>接口与接口赋值</a></li></ul></li><li><a href=#空接口>空接口</a></li><li><a href=#类型推断>类型推断</a><ul><li><a href=#1-接口转实现者>1. 接口转实现者</a></li><li><a href=#2-是否可推断>2. 是否可推断</a></li><li><a href=#3-type-switch>3. type-switch</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>什么是接口？</li><li>如何定义接口？</li><li>如何使用接口？</li><li>如何嵌入接口？</li><li>接口与接口之间如何赋值？</li><li>如何推断接口的实际类型？</li><li>如何使用空接口？</li></ol><h1 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h1><p>接口是通过定义抽象方法来约定实现者的规则，概念和其它语言中有点类似，但对于 Go 语言中接口的实现与接口之间耦合性更低，灵活性更高。</p><p>为了通俗的理解接口的概念，我举个例子，" 假如你受女娲之托让你进行造人的工作，但给你制定了造人的要求，要有吃喝的动作，但具体每个人怎么吃怎么喝那无所谓，只要有了这两个动作就表示你造人成功 "。</p><p>这个例子中女娲制定的要求就是接口，你按照造人的要求去做就称作接口的实现。</p><blockquote><p>也不知道讲明白了没，保佑你可以。</p></blockquote><h2 id=定义>定义<a hidden class=anchor aria-hidden=true href=#定义>#</a></h2><p>现在定义一个 <code>People</code> 的接口，并定义吃喝两个动作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 可不写参数名：Eat(string) error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><code>Eat</code> 和 <code>Drink</code> 方法不需要具体实现。</li><li>方法前不需要 <code>func</code> 关键字。</li><li>方法的参数名称和返回名称可以不写。</li></ul><p>定义后就可以直接声明一个该接口类型变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p><code>p</code> 变量没有初始化，此时值为 <code>nil</code> 。</p><h2 id=实现接口>实现接口<a hidden class=anchor aria-hidden=true href=#实现接口>#</a></h2><p>接口实现的工作是交给自定义类型的，自定义类型实现了接口所有的方法，就实现接口了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>LaoMiao</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>LaoMiao</span>) <span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;在公司偷吃&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>LaoMiao</span>) <span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;在公司偷喝&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><code>LaoMiao</code> 实现了 <code>People</code> 接口中的所有方法，就说明实现了该接口。</li><li>无需使用其它语言中 <code>implements</code> 关键字显示的去实现。</li><li>可同时实现多个接口。</li></ul><p>再看张图，可能就更清晰了，如下：</p><p><img loading=lazy src=/images/2512b88b9b62e9e227da257e3faec07b.png alt=2512b88b9b62e9e227da257e3faec07b.png></p><p>图中“实现者”都包含了 <code>A</code> 和 <code>B</code> 接口的方法，那它都实现了这两个接口。</p><h2 id=接口的使用>接口的使用<a hidden class=anchor aria-hidden=true href=#接口的使用>#</a></h2><p>实现了接口之后，就可以将该类型的实例化赋值给接口类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span> = <span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Eat</span>(<span style=color:#e6db74>&#34;桃子&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在公司偷吃桃子</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p><code>p</code> 为接口类型，实际的实现是 <code>LaoMiao</code> 类型。</p><p>你可能好奇，我为啥不直接调用呢，类似如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Eat</span>(<span style=color:#e6db74>&#34;桃子&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>上面代码没有使用 <code>People</code> 接口类型，但如果我再定义一个类型去实现 <code>People</code> 接口，好处就体现出来了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>LaoSun</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>LaoSun</span>) <span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;在车上吃&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>LaoSun</span>) <span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;在车上喝&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>又增加了一个类型去实现，看清楚这个是 <code>LaoSun</code> ，上面的那个类型是 <code>LaoMiao</code> 。</p><p>现在开始想个问题，如果我想调用这两个类型的方法，并且调用的代码只写一遍，该如何做？喘口气，我告诉你，自然是用接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// interface/main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>People</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>thing1</span>, <span style=color:#a6e22e>thing2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;桃子&#34;</span>, <span style=color:#e6db74>&#34;可乐&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing1</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing2</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>LaoMiao</span>{})
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>LaoSun</span>{})
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在公司偷吃桃子</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在公司偷喝可乐</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在车上吃桃子</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在车上喝可乐</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>该代码增加了一个 <code>Run</code> 函数，该函数接受的类型为接口类型，<code>main</code> 函数中将两个实现接口的类型传递给函数。</p><h3 id=接收者类型与接口>接收者类型与接口<a hidden class=anchor aria-hidden=true href=#接收者类型与接口>#</a></h3><p>在上面的代码中所有实现接口的类型接收者都是值类型，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>LaoSun</span>) <span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>接收者 <code>l</code> 类型为 <code>LaoSun</code> ，如果是指针接收者应该为 <code>*LaoSun</code> 。</p><p>在使用接口类型调用时，接口接受的类型为值类型，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>LaoSun</span>{})
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>该函数的参数 <code>LaoSun{}</code> 为值类型，但其实也可以传递指针类型 <code>Run(&amp;LaoSun{})</code> ，编译器会进行解引用。</p><p>如果接收者为指针类型时，那给接口传值时必须使用指针类型，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GouDan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GouDan</span>) <span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;你管我吃&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GouDan</span>) <span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;你管我喝&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>thing</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>重新定义了一个类型去实现 <code>People</code> 接口并且方法的接收者为指针类型，如果给接口传递值类型时，编译器会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>GouDan</span>{})
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>use</span> <span style=color:#a6e22e>GouDan</span>{} (<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GouDan</span>) <span style=color:#a6e22e>as</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#a6e22e>in</span> <span style=color:#a6e22e>argument</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>Run</span>:
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GouDan</span> <span style=color:#a6e22e>does</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>implement</span> <span style=color:#a6e22e>People</span> (<span style=color:#a6e22e>Drink</span> <span style=color:#a6e22e>method</span> <span style=color:#a6e22e>has</span> <span style=color:#a6e22e>pointer</span> <span style=color:#a6e22e>receiver</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>正确的是，只能传递指针类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Run</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>GouDan</span>{})
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>或</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sun</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>LaoSun</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>LaoSun</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>sun</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h2 id=接口嵌入>接口嵌入<a hidden class=anchor aria-hidden=true href=#接口嵌入>#</a></h2><p>一个接口可以包含另外一个接口，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>People</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Study</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li>定义了一个 <code>Student</code> 接口，对于学生接口自然也会有吃喝的动作，因此无需重复定义，只需要将 <code>People</code> 接口嵌入就可以。</li><li>如果自定义类型想实现 <code>Student</code> 接口，需要将嵌入接口定义的方法和自己所定义的方法都需要实现。</li><li>可嵌入多个接口。</li></ul><h3 id=接口与接口赋值>接口与接口赋值<a hidden class=anchor aria-hidden=true href=#接口与接口赋值>#</a></h3><p>在上面的代码中 <code>People</code> 接口被嵌入到了 <code>Student</code> 接口 ，那这个时候，<code>Student</code> 接口类型变量就可以赋值给 <code>People</code> 类型变量。<br><img loading=lazy src=/images/02178777bd2fabc4a23446dd6bf13825.png alt=02178777bd2fabc4a23446dd6bf13825.png><br>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stu</span> <span style=color:#a6e22e>Student</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pl</span> <span style=color:#a6e22e>People</span> = <span style=color:#a6e22e>stu</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>如果把 <code>People</code> 类型不被嵌入，而只是让 <code>Student</code> 接口包含其方法，那上面接口与接口赋值也是允许的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Eat</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Drink</span>(<span style=color:#a6e22e>thing</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Study</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>总结：<strong>大接口包含了小接口的方法，那大接口就可以赋值给小接口。</strong></p><h2 id=空接口>空接口<a hidden class=anchor aria-hidden=true href=#空接口>#</a></h2><p>空接口表示没有定义任何抽象方法，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Empty</span> <span style=color:#66d9ef>interface</span> {}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p><code>Empty</code> 类型现在就是空的接口，它可以接受任意类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>Empty</span> = <span style=color:#e6db74>&#34;字符串&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>num</span> <span style=color:#a6e22e>Empty</span> = <span style=color:#ae81ff>222</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>平常项目中使用时，为了更简单，其实无需定义空接口，直接使用 <code>interface{}</code> 作为类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>str</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#e6db74>&#34;字符串&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>num</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#ae81ff>222</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>总结一句：<strong>所有类型都实现了空接口，即空接口可以接受任意类型变量</strong>。</p><h2 id=类型推断>类型推断<a hidden class=anchor aria-hidden=true href=#类型推断>#</a></h2><p>在一个接口变量中，如果想知道该接口变量的具体实现类型是谁就需要使用类型推断。</p><h3 id=1-接口转实现者>1. 接口转实现者<a hidden class=anchor aria-hidden=true href=#1-接口转实现者>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>var1</span>.(<span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><code>T</code> 表示你需要推断的类型。</li><li><code>v</code> 为转化后类型为 <code>T</code> 的变量。</li><li><code>var1</code> 可以为空接口。</li></ul><p>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>people</span> <span style=color:#a6e22e>People</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 将 People 类型转化为 LaoMiao 值类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>people</span> = <span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 将 People 类型转化为 LaoMiao 指针类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>people</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>peo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>从例子中可以看出，接口变量中存储的类型和推断时的类型必须相同，如果不相同时，编译器会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>people</span> = <span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 报错
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 正确
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h3 id=2-是否可推断>2. 是否可推断<a hidden class=anchor aria-hidden=true href=#2-是否可推断>#</a></h3><p>如果接口变量中存储的实际类型不确定，那就必须进行判断，如果不判断时出现无法推断的情况，编译器就会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>var1</span>.(<span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>判断其实就是在推断类型时多增加了一个返回值，如果可推断 <code>ok</code> 值为 <code>true</code>，否则为 <code>false</code> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>people</span> = <span style=color:#a6e22e>LaoMiao</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val1</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ok</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>val2</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>people</span>.(<span style=color:#a6e22e>LaoMiao</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ok</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h3 id=3-type-switch>3. type-switch<a hidden class=anchor aria-hidden=true href=#3-type-switch>#</a></h3><p>这个知识点其实在很早之前的 <a href=/golang-if-for-switch/>流程控制</a> 一篇中讲过了，我再讲一遍并补充。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>data</span> = <span style=color:#e6db74>&#34;111&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// data 是接口类型， .(type) 获取实际类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 将实际类型的值赋给 d 变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span>:
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 进入分支后，d 是 string 类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;str&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span>:
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 进入分支后， d 是 int 类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>111</span><span style=color:#a6e22e>str</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li>通过 <code>.(type)</code> 获取接口的实际类型，记住这种方式只能用于 <code>switch</code> 语句中，这也是我为什么单独在这块讲解。</li><li>不能使用 <code>fallthrough</code> 关键字。</li><li>如果只是判断类型，则无需使用 <code>d</code> 变量接受。</li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Go 语言的接口知识点就讲完了，很重要，务必要掌握清楚。那现在问问你知道接口的实现精髓是啥吗？</p><p>我总结下，只要实现了其方法就实现了接口，实现的方法如果满足了多个接口，那就都实现。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.printlove.cn/tags/program_golang/>program_golang</a></li></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/golang-error/><span class=title>« 上一页</span><br><span>Go基础系列：16. 错误与异常</span></a>
<a class=next href=https://www.printlove.cn/golang-pointer/><span class=title>下一页 »</span><br><span>Go基础系列：14. 指针类型</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：15. 接口 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a15.%20%e6%8e%a5%e5%8f%a3&amp;url=https%3a%2f%2fwww.printlove.cn%2fgolang-interface%2f&amp;hashtags=program_golang"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：15. 接口 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a15.%20%e6%8e%a5%e5%8f%a3"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>