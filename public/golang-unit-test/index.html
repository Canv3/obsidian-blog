<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：19. 单元测试 | PrintLove</title><meta name=keywords content="Golang,Go,单元测试"><meta name=description content="Go 语言中如何进行单元测试，代码覆盖率的作用及不同模式，testify 包的使用"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/golang-unit-test/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：19. 单元测试"><meta property="og:description" content="Go 语言中如何进行单元测试，代码覆盖率的作用及不同模式，testify 包的使用"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/golang-unit-test/"><meta property="og:image" content="https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?q=80&w=1000&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-10T00:00:00+00:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?q=80&w=1000&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"><meta name=twitter:title content="Go基础系列：19. 单元测试"><meta name=twitter:description content="Go 语言中如何进行单元测试，代码覆盖率的作用及不同模式，testify 包的使用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：19. 单元测试","item":"https://www.gby.ai/golang-unit-test/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：19. 单元测试","name":"Go基础系列：19. 单元测试","description":"Go 语言中如何进行单元测试，代码覆盖率的作用及不同模式，testify 包的使用","keywords":["Golang","Go","单元测试"],"articleBody":"大家好，我是 “潇洒哥老苗”。\n该系列上篇讲解了 《并发》，今天我们学学 Go 语言中的单元测试。\n依赖 Go 版本：1.16.4。\n源码地址：\nhttps://github.com/miaogaolin/gobasic\n学到什么 什么是单元测试？\n如何编写单元测试？\n什么是代码覆盖率？\n如何使用 testify 包？\n引入 先不讲解 “单元测试” 的概念，在不使用 “单元测试” 的情况下，我们如何测试一个函数或方法的正确性。\n例如，如下函数：\n// gobasic/unittest/add.go func Add(num1, num2 int) int { return num1 + num2 } 这个函数逻辑很简单，只进行 num1 和 num2 两数的相加。在实际开发中对这样的逻辑没必要进行单元测试，现在咱就假设这个函数逻辑很复杂，需要测试才知道对不对。\n测试如下：\npackage main import \"fmt\" func main() { excepted := 5 actual := Add(2, 3) if excepted == actual { fmt.Println(\"成功\") } else { fmt.Println(\"失败\") } } 对于这样的测试方式，它有如下问题：\n测试代码和业务代码混乱、不分离；\n测试完后，测试代码必须删除；\n如果不删除，会参与编译。\n你可能会说，可以使用 debug 方式测试，但这样，没有任何测试过程，后期如果修改了代码，如何确定当时什么样的结果是正确的。\n下来，引入 “单元测试” 的概念，以解决上述所说的问题。\n什么是单元测试 根据维基百科的定义，单元测试又称为模块测试，是针对程序模块（软件设计的最小单元）来进行正确性检验的测试工作。\n在 Go 语言中，测试的最小单元常常是函数和方法。\n测试文件 简单了解了概念后，现在就开始创建一个单元测试文件。\n在很多语言中，常常把测试文件放在一个独立的目录下进行管理，而在 Go 语言中会和源文件放置在一块，即同一目录下。\n例如，对于上面的 Add 函数，所在文件是 add.go，那创建的测试文件也和它放在一块，如下：\nunitest 目录\nadd.go\nadd_test.go 单元测试\n假如源文件的命名是 xxx.go, 那单元测试文件的命名则为 xxx_test.go。如果在编译阶段 xxx_test.go 文件会被忽略。\n写单元测试 下来我们一块在 add_test.go 文件中给 Add 函数写一个单元测试。\n1. 基本结构 先看看基本结构，具体的测试内容没写，如下：\n// gobasic/unittest/add_test.go package unittest import \"testing\" func TestAdd(t *testing.T) { // ... } 导入 testing 标准包；\n创建一个 Test 开头的函数名 TestAdd，Test 是固定写法，后面的 Add 一般和你要测试的函数名对应，当然不对应也没有问题；\n参数类型 *tesing.T 用于打印测试结果，参数中也必须跟上。\n所有的单元测试函数都要按照该要求定义，定义好后，下来看看如何编写测试内容。\n2. 测试内容 测试 Add 函数的计算结果是否正确。\n// gobasic/unittest/add_test.go package unittest import \"testing\" func TestAdd(t *testing.T) { excepted := 4 actual := Add(2, 3) if excepted != actual { t.Errorf(\"excepted：%d, actual:%d\", excepted, actual) } } excepted 函数期待的结果；\nactual 函数真实计算的结果；\n如果不相等，打印出错误。\n在 unittest 目录下运行 go test （或 go test ./）命令，表示运行 unittest 目录下的单元测试，不会再往下递归。如果想往下递归，即当前目录下还有目录，则运行 go test ./... 命令。\n运行结果：\n$ go test --- FAIL: TestAdd (0.00s) add_test.go:11: excepted：4, actual:5 FAIL FAIL github.com/miaogaolin/gobasic/unittest 0.228s FAIL 结果中看出 TestAdd 函数运行失败，并打印出了错误行数 11 和 组装的日志。\n假如你使用了 Goland 工具，直接点击下图的红框位置即可。\n*testing.T 现在对参数类型 T 中的几个方法展开说说，如下：\nError 打印错误日志、标记为失败 FAIL，并继续往下执行。\nErrorf 格式化打印错误日志、标记为失败 FAIL，并继续往下执行。\nFail 不打印日志，结果中只标记为失败 FAIL，并继续往下执行。\nFailNow 不打印日志，结果中只标记为失败 FAIL，但在当前测试函数中不继续往下执行。\nFatal 打印日志、标记为失败，并且内部调用了 FaileNow 函数，也不往下执行。\nFatalf 格式化打印错误日志、标记为失败，并且内部调用了 FaileNow 函数，也不往下执行。\n你可能发现，没有成功的方法，不过确实也没有，只要没有通知错误，那就说明是正确的。正确的测试结果是下面这个样子：\n$ go test ok github.com/miaogaolin/gobasic/unittest 0.244s 测试资源 有时候在你写单元测试时，可能需要读取文件，那这些相关的资源文件就放置在 testdata 目录下。\n示例：\nunittest 目录\nxxx.go\nxxx_test.go\ntestdata 目录\ngo test 和 go vet 在运行 go test 命令后，go vet 命令也会自动运行。\n简单说下 go vet 命令，本篇不过多描述。它用于代码的静态分析，检查编译器检查不出的错误，例如：\n// gobasic/vet/main.go package main import \"fmt\" func main() { fmt.Printf(\"%d\", \"miao\") } // 输出 %!d(string=miao) 看结果是不是很奇怪，是因为占位符 %d 需要的是整数，但给的是字符串。不熟悉占位符的朋友，直接前往 《详解 20 个占位符》。\n对于这种类似的错误，编译器是不会报错的，这时候就用到了 go vet 命令，运行如下：\n$ go vet # github.com/miaogaolin/gobasic/vet .\\main.go:6:2: Printf format %d has arg \"miao\" of wrong type string 所以在测试时无需单独运行 go vet 命令，一个 go test 命令就包含了。\n表格驱动测试 在对于一个函数或方法进行测试时，很多时候要测试多种情况，那对于多种情况如何进行测试呢？下来看看。\n// gobasic/unittest/add_test.go package unittest import \"testing\" func TestAdd1(t *testing.T) { excepted := 5 actual := Add(2, 3) if excepted != actual { t.Errorf(\"case1：excepted：%d, actual:%d\", excepted, actual) } excepted = 10 actual = Add(0, 10) if excepted != actual { t.Errorf(\"case2：excepted：%d, actual:%d\", excepted, actual) } } 通过上述代码，我们可以看出，如果遇到多种情况时，再使用 if 语句判断即可。你可能心里会嘀咕： “这还用你说，不是废话吗！”。\n下来开始我真正想说的，如果我们想要测试的情况比较多，按照上面这种写法看起来就会很冗余，所以我们改为下面的写法：\n// gobasic/unittest/add_test.go package unittest import \"testing\" func TestAddTable(t *testing.T) { type param struct { name string num1, num2, excepted int } testCases := []param{ {name: \"case1\", num1: 2, num2: 3, excepted: 5}, {name: \"case2\", num1: 0, num2: 10, excepted: 10}, } for _, v := range testCases { t.Run(v.name, func(t *testing.T) { actual := Add(v.num1, v.num2) if v.excepted != actual { t.Errorf(\"excepted:%d, actual:%d\", v.excepted, actual) } }) } } 通过切片保存每种想要测试的情况（测试用例），下来只需要通过循环判断即可；\nt.Run 方法，第一个参数是当前测试的名称，第二个是个匿名函数，用来写判断逻辑。\n运行结果：\n$ go test add.go add_test.go -test.run TestAddTable -v === RUN TestAddTable === RUN TestAddTable/case1 === RUN TestAddTable/case2 --- PASS: TestAddTable (0.00s) --- PASS: TestAddTable/case1 (0.00s) --- PASS: TestAddTable/case2 (0.00s) PASS ok command-line-arguments 0.041s go test 命令后的 add.go 和 add_test.go 文件是特意指定需要测试和依赖的文件；\n-test.run 指明测试的函数名；\n-v 展示详细的过程，如果不写，测试成功时，不会打印详细过程。\n缓存 当运行单元测试时，测试的结果会被缓存下来。如果更改了测试代码或源文件，则会重新运行测试，并再次缓存。\n但不是任何情况都可以缓存下来，只有当 go test 命令后跟着目录、指定的文件或包名才可以，举例如下：\ngo test ./\ngo test ./pkg\ngo test add.go add_test.go\ngo test fmt\n如果我在 unittest 目录下运行测试，第一次和第二的结果如下：\n# 第一次 $ go test ./ ok github.com/miaogaolin/gobasic/unittest 0.228s # 第二次 $ go test ./ ok github.com/miaogaolin/gobasic/unittest (cached) 可以看到第二次的结果中出现了 cached 字样，如果你问 “删掉后面的 ./” 可以吗？答：不可以，因为不会进行缓存。\n1. 禁用缓存 如果想禁用缓存，可以使用如下命令运行：\ngo test ./ -count=1 2. 其它情况 上面说过，当单元测试文件或源文件修改时，会重新缓存。\n但还有其它情况也会如此，比如当你的单元测试中涉及了如下情况：\n读取环境变量的内容更改\n读取文件的内容更改\n这两种情况不会影响测试文件和源文件的修改，但还是会重新缓存测试结果。\n并发测试 为了提高多个单元测试的运行效率，我们可以采取并发测试。先看一个没有并发的例子，如下：\nfunc TestA(t *testing.T) { time.Sleep(time.Second) } func TestB(t *testing.T) { time.Sleep(time.Second) } func TestC(t *testing.T) { time.Sleep(time.Second) } 该例子中没有写任何具体的测试逻辑，只是每个函数休眠了 1s 中，目的只是演示测试的时间。\n测试结果如下：\nok command-line-arguments 3.242s 可以看到总共花费了 3.242s。\n下来加入并发，如下：\nfunc TestA(t *testing.T) { t.Parallel() time.Sleep(time.Second) } func TestB(t *testing.T) { t.Parallel() time.Sleep(time.Second) } func TestC(t *testing.T) { t.Parallel() time.Sleep(time.Second) } 在每个测试函数前增加了 t.Parallel() 实现并发。\n测试如下：\nok command-line-arguments 1.049s 很明显可以看到，测试的时间缩短到了 1s，大概是原来时间的三分之一。\n代码覆盖率 代码覆盖率是一个指数，例如：20%、30% 、100% 等。\n它体现了你的项目代码是否得到了足够的测试，指数越大，说明测试的覆盖情况越全面。\n命令如下：\n$ go test -cover PASS coverage: 100.0% of statements ok github.com/miaogaolin/gobasic/unittest 1.045s -cover 输出覆盖率的标识符；\n覆盖率为 100%，说明被测试的函数代码都有运行到，覆盖率 = 已执行语句数 / 总语句数。\n在计算覆盖率时，还有三种模式，不同的模式在已执行语句的次数统计时存在差异性。\n1. 模式 set 这是默认的模式，它的计算方式是 “如果同一语句多次执行只记录一次”。\n举例看个例子，如下：\nfunc GetSex(sex int) string { if sex == 1 { return \"男\" } else { return \"女\" } } 下来给这个函数写个单元测试，如下：\nfunc TestGetSex(t *testing.T) { excepted := \"男\" actual := GetSex(1) if actual != excepted { t.Errorf(\"excepted：%s, actual:%s\", excepted, actual) } } 我就不解释这个测试函数了，你很聪明的。\n运行覆盖率命令：\n$ go test -cover ok command-line-arguments 0.228s coverage: 66.7% of statements 这次的覆盖率可不是 100% 了，那为啥是 66.7%，往下看。\n在终端运行如下命令：\ngo test -coverprofile profile 运行后，会在当前目录生成一个覆盖率的采样文件 profile，打开内容如下：\nmode: set github.com/miaogaolin/gobasic/testcover/sex.go:3.29,4.14 1 1 github.com/miaogaolin/gobasic/testcover/sex.go:4.14,6.3 1 1 github.com/miaogaolin/gobasic/testcover/sex.go:6.8,8.3 1 0 暂时先不介绍这个文件内容细节，先使用这个文件生成一个直观图，命令如下：\ngo tool cover -html profile -html profile 指明将 profile 文件在浏览器渲染出来，运行后会自动在浏览器出现如下图：\n灰色不用管，绿色的已覆盖，红色的未覆盖。\n下来回到 profile 文件的内容，看图说明：\n第一行，覆盖率模式；\n剩下三行，对应下图不同颜色的下划线。\n可得：总语句数为 3，覆盖语句（执行语句）数为 2，计算覆盖率为 2/3 = 66.7%。\n如果想达到 100% 覆盖，只需要增加 else 的测试情况，如下：\nfunc TestGetSex2(t *testing.T) { excepted := \"女\" actual := GetSex(0) if actual != excepted { t.Errorf(\"excepted：%s, actual:%s\", excepted, actual) } } 2. 模式 count 该模式和 set 模式比较相似，唯一的区别是 count 模式对于相同的语句执行次数会进行累计。\n使用下面命令生成 profile 文件：\ngo test -coverprofile profile -covermode count 这次测试，会将 TestGetSex 和 TestGetSex2 函数都运行，自然也会 100% 覆盖。\nprofile 文件内容：\nmode: count github.com/miaogaolin/gobasic/testcover/sex.go:3.29,4.14 1 2 github.com/miaogaolin/gobasic/testcover/sex.go:4.14,6.3 1 1 github.com/miaogaolin/gobasic/testcover/sex.go:6.8,8.3 1 1 如果再切换到 set 模式下生成，唯一不同点是，内容第二行中的最后一个数字 2 在 set 模式下会是 1。\n那 count 模式下为啥是 2 呢？\n因为 if sex == 1 语句被执行了两次，看下图再说明下：\n执行 TestGetSex 和 TestGetSex2 函数时，if sex == 1 都会被执行一次，因此总共 2 次，而剩下的语句只执行了 1 次。\n绿色表示覆盖率最高，下来是 low coverage 对应的颜色，表示低覆盖率。\n总结，count 模式下能看出哪些代码执行的次数多，而 set 模式下不能。\n3. 模式 atomic 该模式和 count 类似，都是统计执行语句的次数，不同点是，在并发情况下 atomic 模式比 count 模式计数更精确。\n来看一个没啥用的并发例子，测试两者统计的结果，如下：\n// gobasic/testatomic/nums.go package testatomic import \"sync\" func AddNumber(num int) int { var wg sync.WaitGroup for i := 0; i \u003c 200; i++ { wg.Add(1) go func(i int) { i += num wg.Done() }(i) } wg.Wait() return num } 该代码创建了 200 个 Goroutine，再对 200 个数并发的与 num 参数相加。\n单元测试的代码就不写了，只要调用了该函数就可以。如果想看，直接在 Github 上看完整代码。\ncount 模式下生成的 profile 文件内容如下：\nmode: count github.com/miaogaolin/gobasic/testatomic/nums.go:5.29,8.27 2 1 github.com/miaogaolin/gobasic/testatomic/nums.go:15.2,16.12 2 1 github.com/miaogaolin/gobasic/testatomic/nums.go:8.27,10.18 2 200 github.com/miaogaolin/gobasic/testatomic/nums.go:10.18,13.4 2 199 直接看最后一行，对应到源码上是 Goroutine 的代码块，即：go func(i int) {...}。\n199 表示的是该语句的执行次数，但循环次数总共是 200 次，所以是不准确的。\n那再以 atomic 模式运行，命令如下：\ngo test -coverprofile profile -covermode atomic profile 文件内容如下：\nmode: atomic github.com/miaogaolin/gobasic/testatomic/nums.go:5.29,8.27 2 1 github.com/miaogaolin/gobasic/testatomic/nums.go:15.2,16.12 2 1 github.com/miaogaolin/gobasic/testatomic/nums.go:8.27,10.18 2 200 github.com/miaogaolin/gobasic/testatomic/nums.go:10.18,13.4 2 200 直接看内容的最后一个数字，这下正确了。\ntestify 包 当对一个项目中写大量的单元测试时，如果按照上述的方式去写，就会产生大量的判断语句。\n例如这样的 if 判断：\nfunc TestAdd(t *testing.T) { excepted := 4 actual := Add(2, 3) if excepted != actual { t.Errorf(\"excepted：%d, actual:%d\", excepted, actual) } } 下来我推荐一个第三方包 testfiy，首先在终端运行如下命令，表示下载该包。\ngo get github.com/stretchr/testify 改写单元测试代码，如下：\npackage unittest import ( \"github.com/stretchr/testify/assert\" \"testing\" ) func TestAdd(t *testing.T) { excepted := 4 actual := Add(2, 3) assert.Equal(t, excepted, actual) } 导入 testify 包下的一个子包 assert；\n使用 assert.Equal 函数简化 if 语句和日志打印，该函数期待 excepted 和 actual 变量相同，如果不相同会打印失败日志。\n看看失败是啥样子，如下：\n--- FAIL: TestAdd (0.00s) add_test.go:11: Error Trace: add_test.go:11 Error: Not equal: expected: 4 actual : 5 Test: TestAdd FAIL FAIL command-line-arguments 0.578s FAIL 也是打印出了期待的值和实际的值，并说明了两值不相等。\n当然该包也不只有 Equal 函数，这个学习就留给自己了，相信你可以的。\n小结 本篇讲解了 Go 语言中如何写单元测试，并讲了代码覆盖率的 3 种统计方式，对于如何给函数和方法写单元测试，一定要掌握。\n如果在测试代码时发现了和我所写的结果有出入，那可能就是版本差异。\n有问题的话，随意讨论。\n","wordCount":"1067","inLanguage":"zh","image":"https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?q=80\u0026w=1000\u0026auto=format\u0026fit=crop\u0026ixlib=rb-4.0.3\u0026ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D","datePublished":"2021-12-10T00:00:00Z","dateModified":"2021-12-10T00:00:00Z","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/golang-unit-test/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：19. 单元测试</h1><div class=post-meta><span title='2021-12-10 00:00:00 +0000 UTC'>2021-12-10</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a19.%20%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#引入>引入</a></li><li><a href=#什么是单元测试>什么是单元测试</a></li><li><a href=#测试文件>测试文件</a></li><li><a href=#写单元测试>写单元测试</a><ul><li><a href=#1-基本结构>1. 基本结构</a></li><li><a href=#2-测试内容>2. 测试内容</a></li></ul></li><li><a href=#testingt>*testing.T</a></li><li><a href=#测试资源>测试资源</a></li><li><a href=#go-test-和-go-vet>go test 和 go vet</a></li><li><a href=#表格驱动测试>表格驱动测试</a></li><li><a href=#缓存>缓存</a><ul><li><a href=#1-禁用缓存>1. 禁用缓存</a></li><li><a href=#2-其它情况>2. 其它情况</a></li></ul></li><li><a href=#并发测试>并发测试</a></li><li><a href=#代码覆盖率>代码覆盖率</a><ul><li><a href=#1-模式-set>1. 模式 set</a></li><li><a href=#2-模式-count>2. 模式 count</a></li><li><a href=#3-模式-atomic>3. 模式 atomic</a></li></ul></li><li><a href=#testify-包>testify 包</a></li><li><a href=#小结>小结</a></li></ul></nav></div></details></div><div class=post-content><p>大家好，我是 “潇洒哥老苗”。</p><p>该系列上篇讲解了 <a href=/golang-concurrency/>《并发》</a>，今天我们学学 Go 语言中的单元测试。</p><p>依赖 Go 版本：1.16.4。</p><p>源码地址：</p><p><a href=https://github.com/miaogaolin/gobasic>https://github.com/miaogaolin/gobasic</a></p><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li><p>什么是单元测试？</p></li><li><p>如何编写单元测试？</p></li><li><p>什么是代码覆盖率？</p></li><li><p>如何使用 testify 包？</p></li></ol><h2 id=引入>引入<a hidden class=anchor aria-hidden=true href=#引入>#</a></h2><p>先不讲解 “单元测试” 的概念，在不使用 “单元测试” 的情况下，我们如何测试一个函数或方法的正确性。</p><p>例如，如下函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/unittest/add.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>num1</span>, <span style=color:#a6e22e>num2</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>num1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>num2</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>这个函数逻辑很简单，只进行 num1 和 num2 两数的相加。在实际开发中对这样的逻辑没必要进行单元测试，现在咱就假设这个函数逻辑很复杂，需要测试才知道对不对。</p><p>测试如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>excepted</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;成功&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;失败&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>对于这样的测试方式，它有如下问题：</p><ul><li><p>测试代码和业务代码混乱、不分离；</p></li><li><p>测试完后，测试代码必须删除；</p></li><li><p>如果不删除，会参与编译。</p></li></ul><p>你可能会说，可以使用 debug 方式测试，但这样，没有任何测试过程，后期如果修改了代码，如何确定当时什么样的结果是正确的。</p><p>下来，引入 “单元测试” 的概念，以解决上述所说的问题。</p><h2 id=什么是单元测试>什么是单元测试<a hidden class=anchor aria-hidden=true href=#什么是单元测试>#</a></h2><p>根据维基百科的定义，单元测试又称为模块测试，是针对程序模块（软件设计的最小单元）来进行正确性检验的测试工作。</p><p>在 Go 语言中，测试的最小单元常常是函数和方法。</p><h2 id=测试文件>测试文件<a hidden class=anchor aria-hidden=true href=#测试文件>#</a></h2><p>简单了解了概念后，现在就开始创建一个单元测试文件。</p><p>在很多语言中，常常把测试文件放在一个独立的目录下进行管理，而在 Go 语言中会和源文件放置在一块，即同一目录下。</p><p>例如，对于上面的 <code>Add</code> 函数，所在文件是 <code>add.go</code>，那创建的测试文件也和它放在一块，如下：</p><ul><li><p>unitest 目录</p><ul><li><p>add.go</p></li><li><p>add_test.go 单元测试</p></li></ul></li></ul><p>假如源文件的命名是 <strong>xxx.go</strong>, 那单元测试文件的命名则为 <strong>xxx_test.go</strong>。如果在编译阶段 xxx_test.go 文件会被忽略。</p><h2 id=写单元测试>写单元测试<a hidden class=anchor aria-hidden=true href=#写单元测试>#</a></h2><p>下来我们一块在 add_test.go 文件中给 Add 函数写一个单元测试。</p><h3 id=1-基本结构>1. 基本结构<a hidden class=anchor aria-hidden=true href=#1-基本结构>#</a></h3><p>先看看基本结构，具体的测试内容没写，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/unittest/add_test.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>unittest</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAdd</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p>导入 testing 标准包；</p></li><li><p>创建一个 <strong>Test</strong> 开头的函数名 TestAdd，Test 是固定写法，后面的 Add 一般和你要测试的函数名对应，当然不对应也没有问题；</p></li><li><p>参数类型 <code>*tesing.T</code> 用于打印测试结果，参数中也必须跟上。</p></li></ul><p>所有的单元测试函数都要按照该要求定义，定义好后，下来看看如何编写测试内容。</p><h3 id=2-测试内容>2. 测试内容<a hidden class=anchor aria-hidden=true href=#2-测试内容>#</a></h3><p>测试 Add 函数的计算结果是否正确。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/unittest/add_test.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>unittest</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAdd</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>excepted</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;excepted：%d, actual:%d&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p>excepted 函数期待的结果；</p></li><li><p>actual 函数真实计算的结果；</p></li><li><p>如果不相等，打印出错误。</p></li></ul><p>在 unittest 目录下运行 <code>go test</code> （或 <code>go test ./</code>）命令，表示运行 unittest 目录下的单元测试，不会再往下递归。如果想往下递归，即当前目录下还有目录，则运行 <code>go test ./...</code> 命令。</p><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>--- FAIL: TestAdd <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    add_test.go:11: excepted：4, actual:5
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL    github.com/miaogaolin/gobasic/unittest  0.228s
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>结果中看出 TestAdd 函数运行失败，并打印出了错误行数 11 和 组装的日志。</p><p>假如你使用了 Goland 工具，直接点击下图的红框位置即可。</p><p><img loading=lazy src=https://imgs-go-instagram.insloves.com/images/Snipaste_2021-12-08_17-53-20.png alt></p><h2 id=testingt>*testing.T<a hidden class=anchor aria-hidden=true href=#testingt>#</a></h2><p>现在对参数类型 T 中的几个方法展开说说，如下：</p><ul><li><p><code>Error</code> 打印错误日志、标记为失败 FAIL，并继续往下执行。</p></li><li><p><code>Errorf</code> 格式化打印错误日志、标记为失败 FAIL，并继续往下执行。</p></li><li><p><code>Fail</code> 不打印日志，结果中只标记为失败 FAIL，并继续往下执行。</p></li><li><p><code>FailNow</code> 不打印日志，结果中只标记为失败 FAIL，但在当前测试函数中不继续往下执行。</p></li><li><p><code>Fatal</code> 打印日志、标记为失败，并且内部调用了 FaileNow 函数，也不往下执行。</p></li><li><p><code>Fatalf</code> 格式化打印错误日志、标记为失败，并且内部调用了 FaileNow 函数，也不往下执行。</p></li></ul><p>你可能发现，没有成功的方法，不过确实也没有，只要没有通知错误，那就说明是正确的。正确的测试结果是下面这个样子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      github.com/miaogaolin/gobasic/unittest  0.244s
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h2 id=测试资源>测试资源<a hidden class=anchor aria-hidden=true href=#测试资源>#</a></h2><p>有时候在你写单元测试时，可能需要读取文件，那这些相关的资源文件就放置在 testdata 目录下。</p><p>示例：</p><ul><li><p>unittest 目录</p><ul><li><p>xxx.go</p></li><li><p>xxx_test.go</p></li><li><p>testdata 目录</p></li></ul></li></ul><h2 id=go-test-和-go-vet>go test 和 go vet<a hidden class=anchor aria-hidden=true href=#go-test-和-go-vet>#</a></h2><p>在运行 <code>go test</code> 命令后，<code>go vet</code> 命令也会自动运行。</p><p>简单说下 <code>go vet</code> 命令，本篇不过多描述。它用于代码的静态分析，检查编译器检查不出的错误，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/vet/main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#e6db74>&#34;miao&#34;</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>%</span>!<span style=color:#a6e22e>d</span>(<span style=color:#66d9ef>string</span>=<span style=color:#a6e22e>miao</span>)
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>看结果是不是很奇怪，是因为占位符 %d 需要的是整数，但给的是字符串。不熟悉占位符的朋友，直接前往 <a href=/golang-format/>《详解 20 个占位符》</a>。</p><p>对于这种类似的错误，编译器是不会报错的，这时候就用到了 <code>go vet</code> 命令，运行如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go vet
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e># github.com/miaogaolin/gobasic/vet</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>.<span style=color:#ae81ff>\m</span>ain.go:6:2: Printf format %d has arg <span style=color:#e6db74>&#34;miao&#34;</span> of wrong type string
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>所以在测试时无需单独运行 <code>go vet</code> 命令，一个 <code>go test</code> 命令就包含了。</p><h2 id=表格驱动测试>表格驱动测试<a hidden class=anchor aria-hidden=true href=#表格驱动测试>#</a></h2><p>在对于一个函数或方法进行测试时，很多时候要测试多种情况，那对于多种情况如何进行测试呢？下来看看。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/unittest/add_test.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>unittest</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAdd1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>excepted</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;case1：excepted：%d, actual:%d&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> = <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>excepted</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;case2：excepted：%d, actual:%d&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>通过上述代码，我们可以看出，如果遇到多种情况时，再使用 if 语句判断即可。你可能心里会嘀咕： “这还用你说，不是废话吗！”。</p><p>下来开始我真正想说的，如果我们想要测试的情况比较多，按照上面这种写法看起来就会很冗余，所以我们改为下面的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/unittest/add_test.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>unittest</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAddTable</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>param</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>name</span>                 <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>num1</span>, <span style=color:#a6e22e>num2</span>, <span style=color:#a6e22e>excepted</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>testCases</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>param</span>{
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;case1&#34;</span>, <span style=color:#a6e22e>num1</span>: <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>num2</span>: <span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>excepted</span>: <span style=color:#ae81ff>5</span>},
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;case2&#34;</span>, <span style=color:#a6e22e>num1</span>: <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>num2</span>: <span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>excepted</span>: <span style=color:#ae81ff>10</span>},
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>testCases</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>name</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>num1</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>num2</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;excepted:%d, actual:%d&#34;</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p>通过切片保存每种想要测试的情况（测试用例），下来只需要通过循环判断即可；</p></li><li><p><code>t.Run</code> 方法，第一个参数是当前测试的名称，第二个是个匿名函数，用来写判断逻辑。</p></li></ul><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$  go test add.go add_test.go -test.run TestAddTable -v
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestAddTable
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestAddTable/case1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestAddTable/case2
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>--- PASS: TestAddTable <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    --- PASS: TestAddTable/case1 <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    --- PASS: TestAddTable/case2 <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      command-line-arguments  0.041s
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p><code>go test</code> 命令后的 add.go 和 add_test.go 文件是特意指定需要测试和依赖的文件；</p></li><li><p><code>-test.run</code> 指明测试的函数名；</p></li><li><p><code>-v</code> 展示详细的过程，如果不写，测试成功时，不会打印详细过程。</p></li></ul><h2 id=缓存>缓存<a hidden class=anchor aria-hidden=true href=#缓存>#</a></h2><p>当运行单元测试时，测试的结果会被缓存下来。如果<strong>更改了测试代码或源文件</strong>，则会重新运行测试，并再次缓存。</p><p>但不是任何情况都可以缓存下来，只有当 <code>go test</code> 命令后跟着目录、指定的文件或包名才可以，举例如下：</p><ul><li><p>go test ./</p></li><li><p>go test ./pkg</p></li><li><p>go test add.go add_test.go</p></li><li><p>go test fmt</p></li></ul><p>如果我在 unittest 目录下运行测试，第一次和第二的结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e># 第一次</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test ./
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      github.com/miaogaolin/gobasic/unittest  0.228s
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e># 第二次</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test ./
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      github.com/miaogaolin/gobasic/unittest  <span style=color:#f92672>(</span>cached<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>可以看到第二次的结果中出现了 <strong>cached</strong> 字样，如果你问 “删掉后面的 <code>./</code>” 可以吗？答：不可以，因为不会进行缓存。</p><h3 id=1-禁用缓存>1. 禁用缓存<a hidden class=anchor aria-hidden=true href=#1-禁用缓存>#</a></h3><p>如果想禁用缓存，可以使用如下命令运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>go test ./ -count<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h3 id=2-其它情况>2. 其它情况<a hidden class=anchor aria-hidden=true href=#2-其它情况>#</a></h3><p>上面说过，当单元测试文件或源文件修改时，会重新缓存。</p><p>但还有其它情况也会如此，比如当你的单元测试中涉及了如下情况：</p><ul><li><p>读取环境变量的内容更改</p></li><li><p>读取文件的内容更改</p></li></ul><p>这两种情况不会影响测试文件和源文件的修改，但还是会重新缓存测试结果。</p><h2 id=并发测试>并发测试<a hidden class=anchor aria-hidden=true href=#并发测试>#</a></h2><p>为了提高多个单元测试的运行效率，我们可以采取并发测试。先看一个没有并发的例子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestA</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestB</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestC</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>该例子中没有写任何具体的测试逻辑，只是每个函数休眠了 1s 中，目的只是演示测试的时间。</p><p>测试结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      command-line-arguments  3.242s
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>可以看到总共花费了 3.242s。</p><p>下来加入并发，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestA</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Parallel</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestB</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Parallel</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestC</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Parallel</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>在每个测试函数前增加了 <code>t.Parallel()</code> 实现并发。</p><p>测试如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      command-line-arguments  1.049s
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>很明显可以看到，测试的时间缩短到了 1s，大概是原来时间的三分之一。</p><h2 id=代码覆盖率>代码覆盖率<a hidden class=anchor aria-hidden=true href=#代码覆盖率>#</a></h2><p>代码覆盖率是一个指数，例如：20%、30% 、100% 等。</p><p>它体现了你的项目代码是否得到了足够的测试，指数越大，说明测试的覆盖情况越全面。</p><p>命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test -cover
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>coverage: 100.0% of statements
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      github.com/miaogaolin/gobasic/unittest  1.045s
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p><code>-cover</code> 输出覆盖率的标识符；</p></li><li><p>覆盖率为 100%，说明被测试的函数代码都有运行到，<strong>覆盖率 = 已执行语句数 / 总语句数</strong>。</p></li></ul><p>在计算覆盖率时，还有三种模式，不同的模式在已执行语句的次数统计时存在差异性。</p><h3 id=1-模式-set>1. 模式 set<a hidden class=anchor aria-hidden=true href=#1-模式-set>#</a></h3><p>这是默认的模式，它的计算方式是 “如果同一语句多次执行只记录一次”。</p><p>举例看个例子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetSex</span>(<span style=color:#a6e22e>sex</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;男&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;女&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>下来给这个函数写个单元测试，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestGetSex</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;男&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetSex</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>actual</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>excepted</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;excepted：%s, actual:%s&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>我就不解释这个测试函数了，你很聪明的。</p><p>运行覆盖率命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>$ go test -cover
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>ok      command-line-arguments  0.228s  coverage: 66.7% of statements
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>这次的覆盖率可不是 100% 了，那为啥是 66.7%，往下看。</p><p>在终端运行如下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>go test -coverprofile profile
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>运行后，会在当前目录生成一个覆盖率的采样文件 profile，打开内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>  
</span></span><span style=display:flex><span>mode: set
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:3.29,4.14 1 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:4.14,6.3 1 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:6.8,8.3 1 0
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>暂时先不介绍这个文件内容细节，先使用这个文件生成一个直观图，命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>go tool cover -html profile
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p><code>-html profile</code> 指明将 profile 文件在浏览器渲染出来，运行后会自动在浏览器出现如下图：</p><p><img loading=lazy src=https://imgs-go-instagram.insloves.com/images/Snipaste_2021-12-10_17-54-48.png alt></p><p>灰色不用管，绿色的已覆盖，红色的未覆盖。</p><p>下来回到 profile 文件的内容，看图说明：</p><p><img loading=lazy src=https://imgs-go-instagram.insloves.com/images/test-set.png alt></p><ul><li><p>第一行，覆盖率模式；</p></li><li><p>剩下三行，对应下图不同颜色的下划线。</p></li></ul><p><img loading=lazy src=https://imgs-go-instagram.insloves.com/images/set-html-profile.png alt></p><p>可得：总语句数为 3，覆盖语句（执行语句）数为 2，计算覆盖率为 2/3 = 66.7%。</p><p>如果想达到 100% 覆盖，只需要增加 else 的测试情况，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestGetSex2</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;女&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetSex</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>actual</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>excepted</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;excepted：%s, actual:%s&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><h3 id=2-模式-count>2. 模式 count<a hidden class=anchor aria-hidden=true href=#2-模式-count>#</a></h3><p>该模式和 set 模式比较相似，唯一的区别是 count 模式对于相同的语句执行次数会进行累计。</p><p>使用下面命令生成 profile 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>go test -coverprofile profile -covermode count
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>这次测试，会将 TestGetSex 和 TestGetSex2 函数都运行，自然也会 100% 覆盖。</p><p>profile 文件内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  
</span></span><span style=display:flex><span>mode: count
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:3.29,4.14 1 2
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:4.14,6.3 1 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testcover/sex.go:6.8,8.3 1 1
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>如果再切换到 set 模式下生成，唯一不同点是，内容第二行中的最后一个数字 2 在 set 模式下会是 1。</p><p>那 count 模式下为啥是 2 呢？</p><p>因为 <code>if sex == 1</code> 语句被执行了两次，看下图再说明下：</p><p><img loading=lazy src=https://imgs-go-instagram.insloves.com/images/test-mode-count-html.png alt></p><ul><li><p>执行 TestGetSex 和 TestGetSex2 函数时，<code>if sex == 1</code> 都会被执行一次，因此总共 2 次，而剩下的语句只执行了 1 次。</p></li><li><p>绿色表示覆盖率最高，下来是 low coverage 对应的颜色，表示低覆盖率。</p></li></ul><p>总结，count 模式下能看出哪些代码执行的次数多，而 set 模式下不能。</p><h3 id=3-模式-atomic>3. 模式 atomic<a hidden class=anchor aria-hidden=true href=#3-模式-atomic>#</a></h3><p>该模式和 count 类似，都是统计执行语句的次数，不同点是，在并发情况下 atomic 模式比 count 模式计数更精确。</p><p>来看一个没啥用的并发例子，测试两者统计的结果，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// gobasic/testatomic/nums.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>testatomic</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddNumber</span>(<span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>200</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>num</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		}(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>num</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>该代码创建了 200 个 Goroutine，再对 200 个数并发的与 <code>num</code> 参数相加。</p><p>单元测试的代码就不写了，只要调用了该函数就可以。如果想看，直接在 Github 上看完整代码。</p><p>count 模式下生成的 profile 文件内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  
</span></span><span style=display:flex><span>mode: count
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:5.29,8.27 2 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:15.2,16.12 2 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:8.27,10.18 2 200
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:10.18,13.4 2 199
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>直接看最后一行，对应到源码上是 Goroutine 的代码块，即：<code>go func(i int) {...}</code>。</p><p>199 表示的是该语句的执行次数，但循环次数总共是 200 次，所以是不准确的。</p><p>那再以 atomic 模式运行，命令如下：</p><pre tabindex=0><code>  
go test -coverprofile profile -covermode atomic
  
</code></pre><p>profile 文件内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  
</span></span><span style=display:flex><span>mode: atomic
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:5.29,8.27 2 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:15.2,16.12 2 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:8.27,10.18 2 200
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>github.com/miaogaolin/gobasic/testatomic/nums.go:10.18,13.4 2 200
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>直接看内容的最后一个数字，这下正确了。</p><h2 id=testify-包>testify 包<a hidden class=anchor aria-hidden=true href=#testify-包>#</a></h2><p>当对一个项目中写大量的单元测试时，如果按照上述的方式去写，就会产生大量的判断语句。</p><p>例如这样的 if 判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAdd</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>excepted</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>actual</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;excepted：%d, actual:%d&#34;</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>下来我推荐一个第三方包 testfiy，首先在终端运行如下命令，表示下载该包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>go get github.com/stretchr/testify
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>改写单元测试代码，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>unittest</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/stretchr/testify/assert&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestAdd</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>excepted</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>actual</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>excepted</span>, <span style=color:#a6e22e>actual</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><ul><li><p>导入 testify 包下的一个子包 assert；</p></li><li><p>使用 <code>assert.Equal</code> 函数简化 if 语句和日志打印，该函数期待 excepted 和 actual 变量相同，如果不相同会打印失败日志。</p></li></ul><p>看看失败是啥样子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  
</span></span><span style=display:flex><span>--- FAIL: TestAdd <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    add_test.go:11: 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                Error Trace:    add_test.go:11
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                Error:          Not equal: 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                                expected: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                                actual  : <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                Test:           TestAdd
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL    command-line-arguments  0.578s
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>FAIL
</span></span><span style=display:flex><span>  
</span></span></code></pre></div><p>也是打印出了期待的值和实际的值，并说明了两值不相等。</p><p>当然该包也不只有 Equal 函数，这个学习就留给自己了，相信你可以的。</p><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>本篇讲解了 Go 语言中如何写单元测试，并讲了代码覆盖率的 3 种统计方式，对于如何给函数和方法写单元测试，一定要掌握。</p><p>如果在测试代码时发现了和我所写的结果有出入，那可能就是版本差异。</p><p>有问题的话，随意讨论。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.gby.ai/tags/program_golang/>program_golang</a></li></ul><nav class=paginav><a class=prev href=https://www.gby.ai/vercel-notion/><span class=title>« 上一页</span><br><span>Vercel + Notion 建个人博客</span></a>
<a class=next href=https://www.gby.ai/protobuf/><span class=title>下一页 »</span><br><span>深入微服务：3. Protobuf 为啥比 JSON、XML 牛？</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：19. 单元测试 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a19.%20%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95&amp;url=https%3a%2f%2fwww.gby.ai%2fgolang-unit-test%2f&amp;hashtags=program_golang"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：19. 单元测试 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a19.%20%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>