<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：8. 内置集合 - 切片 | PrintLove</title><meta name=keywords content="go,切片,数组"><meta name=description content="一文搞定 Go 语言切片，并对比了数组与切片的区别"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/golang-slice/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：8. 内置集合 - 切片"><meta property="og:description" content="一文搞定 Go 语言切片，并对比了数组与切片的区别"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/golang-slice/"><meta property="og:image" content="https://images.unsplash.com/photo-1607292798226-fee8a80425f6?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw2MHx8c2V0fGVufDB8MHx8fDE3MDMzMDIxNDZ8MA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T16:18:56+08:00"><meta property="article:modified_time" content="2021-07-15T16:18:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1607292798226-fee8a80425f6?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw2MHx8c2V0fGVufDB8MHx8fDE3MDMzMDIxNDZ8MA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：8. 内置集合 - 切片"><meta name=twitter:description content="一文搞定 Go 语言切片，并对比了数组与切片的区别"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：8. 内置集合 - 切片","item":"https://www.gby.ai/golang-slice/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：8. 内置集合 - 切片","name":"Go基础系列：8. 内置集合 - 切片","description":"一文搞定 Go 语言切片，并对比了数组与切片的区别","keywords":["go","切片","数组"],"articleBody":"学到什么 什么是切片？ 如何创建切片？ 如何获取切片长度和容量？ 切片和数组的关系？ 操作切片具体元素？ 切片元素如何追加和移除？ 切片是引用类型还是值类型？ 如何拷贝切片？ 如何创建多维切片？ 切片字符串是啥？ 概念 在学习切片之前请先将上篇文章《内置集合 - 数组》搞明白。\n切片使用起来类似长度可变的数组，不像数组长度是固定的。但切片的底层使用的还是数组，切片只是保存了对数组的引用，帮着管理数组，实现可变的效果。\n声明 格式： var 切片名称 []数据类型\n和数组声明的区别是，是否指明了长度，没有长度则为切片。\nvar nums []int 注：切片未初始化默认为 nil ，长度为 0 。如果清空切片可以赋值 nil，例: nums = nil 。\n初始化 1. make 函数 使用 make 函数初始化切片，容量（马上有讲）参数可以省略，省略后长度和容量相等，格式如下：\n切片名称 := make([]数据类型，长度，容量) 示例：\n// 长度为 2，容量为 5 nums := make([]int, 2, 5) 下图是示例代码的原理图，下来深层了解切片。\n蓝色区域为切片的结构，它包含数组的指针（ptr）、切片长度（len）和切片容量（cap）。\nptr：数组指针，保存数组的内存地址，指向数组的具体索引。 len：切片的长度，可以使用 len(nums) 函数获取，表示从指针对应的索引位置开始所使用的长度。 cap：切片的容量，可以使用 cap(nums) 函数获取，表示引用数组的长度。 黄色区域为切片底层引用的数组，数组的长度就是切片的容量。\n2. 初始化具体值 nums := []int{1, 2, 3} 初始化了一个长度为 3 的切片，此时容量也为 3。\n操作具体元素 切片中元素的具体操作和数组的方式是一样的。如果获取元素时超出切片长度，即使没有超出容量，编译器也会报错。\nnums := []int{1, 2, 3} // 设置索引 1 的元素为 4 nums[1] = 4 fmt.Println(nums[1]) // 输出 4 获取子集 定义了一个切片或数组后，可以获取其中的一部分，即子集。\n格式： 切片或数组[开始索引:结束索引]\n获取从“开始索引”到“结束索引”的子集，包含开始索引，但不包含结束索引。如果是数组获取子集后，类型会转化为切片类型。\n// 切片 nums := []int{1, 2, 3, 4, 5} // 获取切片子集 nums1 := nums[2:4] // []int{3, 4} // 数组 arr := [5]int{1, 2, 3, 4, 5} // nums2 为切片类型 nums2 := arr[2:4] // []int{3, 4} 省略索引 “开始索引”和“结束索引”都可以省略。\n开始索引省略，表示子集从索引 0 开始到结束索引。 结束索引省略，表示子集从开始索引到最后结束。 都省略，如果是切片两者一样，如果是数组会转化为切片类型。 nums := []int{1, 2, 3, 4, 5} // 开始索引省略 nums1 := nums[:3] // []int{1, 2, 3} // 结束索引省略 nums2 := nums[2:] // []int{3, 4, 5} // nums3 和 nums 相同 // 等价于：nums3 := nums nums3 := nums[:] 如果代码中 nums 为数组，那 nums[:] 会将数组转化为切片。下来看看以上代码的原理图，这样会加深理解。\n从图中可以看出所有的切片都指向同一个数组，这也说明了切片是一个引用类型，它在传递时不会进行拷贝。\n追加和移除元素 往切片中追加元素，使用到 append 函数，此函数只能追加到切片末尾。\n// collection/slice-append.go nums := []int{1, 2, 3} nums = append(nums, 2) nums = append(nums, 4, 5) fmt.Println(nums) // 输出 [1 2 3 2 4 5] 如果想追加到切片开头，没有原生的函数，使用 append 变向的实现，这种方式其实就是合并两个切片。\n// collection/slice-append-front.go nums := []int{1, 2, 3} // ... 三个点表示将切片元素展开传递给函数 nums = append([]int{4}, nums...) fmt.Println(nums) // 输出 [4 1 2 3] 如何移除某个元素呢，使用切片子集和 append 函数变向实现。\n// collection/slice-append-remove.go nums := []int{1, 2, 3, 4, 5} // 移除索引为 2 的元素值 3 nums = append(nums[:2], nums[3:]...) fmt.Println(nums) // 输出 [1 2 4 5] 切片拷贝 1. copy 函数 从上面了解到切片是一个引用类型，因此不能像数组一样直接赋值给一个新变量就会产生拷贝。下来使用 copy 函数完成切片的拷贝。\n// collection/slice-copy-1.go // 将 nums 拷贝到 numsCopy nums := []int{1, 2, 3} numsCopy := make([]int, 3) copy(numsCopy, nums) // 修改了 numsCopy，不会对 nums 产生影响 numsCopy[0] = 2 fmt.Println(\"nums:\", nums) fmt.Println(\"numsCopy:\", numsCopy) // 输出 nums: [1 2 3] numsCopy: [2 2 3] numsCopy 长度可以小于或大于 nums 的长度，如果小于就会拷贝 nums 前面一部分，大于会保留 numsCopy 后面一部分。\n// collection/slice-copy-2.go // numsCopy 长度小于 nums nums := []int{1, 2, 3} numsCopy := make([]int, 2) // 前面两个元素 1 和 2 被复制 copy(numsCopy, nums) fmt.Println(\"numsCopy(小于):\", numsCopy) // numsCopy 长度大于 nums numsCopy = []int{4, 5, 6, 7} // 4,5,6 会被覆盖，保留 7 copy(numsCopy, nums) fmt.Println(\"numsCopy(大于):\", numsCopy) // 输出 numsCopy(小于): [1 2] numsCopy(大于): [1 2 3 7] 2. “长度 \u003e 容量”触发拷贝 使用 append 函数给切片追加元素时，如果追加的长度大于切片的容量时，切片的底层数组空间则重新开辟一块比原来大的地方，并把原来的数组值拷贝一份。\n注解：\n图中”新数组“两个位置就是切片长度大于容量的时刻，这两个时刻会自动开辟新数组，与原来的数组没有任何关联，只是把值拷贝了一份。 图中创建”新数组“时，容量的大小是原来的 2 倍，但这不是一成不变的，不同情况算法也会不一样，想要了解清楚我推荐一篇文章《深度解密Go语言之Slice》。 多维切片 这块和多维数组是类似的，唯一的不同点是切片没有指明长度，举个例子：\n// 声明二维切片 var mult [][]int // 初始化二维切片 students := [][]int{ {2, 2, 0}, {2, 2, 2}, {2, 1, 2}, {2, 2, 2}, } 注：如果想创建三维切片、四维切片，只要和多维数组类比就行。\n切片字符串 这个是啥呢？是字符串可以使用上面的子集用法，来获取字符串中的一部分。\nstr := \"I'm laomiao.\" fmt.Println(str[4:7]) // 输出 lao 总结 本篇围绕”切片“进行了重点讲解，在实际开发中也常常被使用，所以一定要掌握清楚。文中没有写明如何遍历切片，是因为它和数组的使用是一样的，如果不懂，请翻阅上篇文章。\n","wordCount":"424","inLanguage":"zh","image":"https://images.unsplash.com/photo-1607292798226-fee8a80425f6?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw2MHx8c2V0fGVufDB8MHx8fDE3MDMzMDIxNDZ8MA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-07-15T16:18:56+08:00","dateModified":"2021-07-15T16:18:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/golang-slice/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：8. 内置集合 - 切片</h1><div class=post-meta><span title='2021-07-15 16:18:56 +0800 CST'>2021-07-15</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a8.%20%e5%86%85%e7%bd%ae%e9%9b%86%e5%90%88%20-%20%e5%88%87%e7%89%87.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#概念>概念</a></li><li><a href=#声明>声明</a></li><li><a href=#初始化>初始化</a><ul><li><a href=#1-make-函数>1. make 函数</a></li><li><a href=#2-初始化具体值>2. 初始化具体值</a></li></ul></li><li><a href=#操作具体元素>操作具体元素</a></li><li><a href=#获取子集>获取子集</a><ul><li><a href=#省略索引>省略索引</a></li></ul></li><li><a href=#追加和移除元素>追加和移除元素</a></li><li><a href=#切片拷贝>切片拷贝</a><ul><li><a href=#1-copy-函数>1. copy 函数</a></li><li><a href=#2-长度--容量触发拷贝>2. “长度 > 容量”触发拷贝</a></li></ul></li><li><a href=#多维切片>多维切片</a></li><li><a href=#切片字符串>切片字符串</a></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>什么是切片？</li><li>如何创建切片？</li><li>如何获取切片长度和容量？</li><li>切片和数组的关系？</li><li>操作切片具体元素？</li><li>切片元素如何追加和移除？</li><li>切片是引用类型还是值类型？</li><li>如何拷贝切片？</li><li>如何创建多维切片？</li><li>切片字符串是啥？</li></ol><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><p>在学习切片之前请先将上篇文章《<a href=/golang-array/>内置集合 - 数组</a>》搞明白。</p><p>切片使用起来类似长度可变的数组，不像数组长度是固定的。但切片的底层使用的还是数组，切片只是保存了对数组的引用，帮着管理数组，实现可变的效果。</p><h2 id=声明>声明<a hidden class=anchor aria-hidden=true href=#声明>#</a></h2><p>格式： <code>var 切片名称 []数据类型</code></p><p>和数组声明的区别是，是否指明了长度，没有长度则为切片。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>  
</span></span></code></pre></div><p>注：切片未初始化默认为 nil ，长度为 0 。如果清空切片可以赋值 nil，例: <code>nums = nil</code> 。</p><h2 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h2><h3 id=1-make-函数>1. make 函数<a hidden class=anchor aria-hidden=true href=#1-make-函数>#</a></h3><p>使用 make 函数初始化切片，容量（马上有讲）参数可以省略，省略后长度和容量相等，格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>切片名称</span> <span style=color:#f92672>:=</span> make([]<span style=color:#960050;background-color:#1e0010>数据类型，长度，容量</span>)  
</span></span></code></pre></div><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 长度为 2，容量为 5  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>)  
</span></span></code></pre></div><p>下图是示例代码的原理图，下来深层了解切片。</p><p><img loading=lazy src=/images/20231207161282.webp alt=20231207161282.webp></p><p><strong>蓝色区域为切片的结构</strong>，它包含数组的指针（ptr）、切片长度（len）和切片容量（cap）。</p><ul><li>ptr：数组指针，保存数组的内存地址，指向数组的具体索引。</li><li>len：切片的长度，可以使用 <code>len(nums)</code> 函数获取，表示从指针对应的索引位置开始所使用的长度。</li><li>cap：切片的容量，可以使用 <code>cap(nums)</code> 函数获取，表示引用数组的长度。</li></ul><p><strong>黄色区域为切片底层引用的数组</strong>，数组的长度就是切片的容量。</p><h3 id=2-初始化具体值>2. 初始化具体值<a hidden class=anchor aria-hidden=true href=#2-初始化具体值>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span></code></pre></div><p>初始化了一个长度为 3 的切片，此时容量也为 3。</p><h2 id=操作具体元素>操作具体元素<a hidden class=anchor aria-hidden=true href=#操作具体元素>#</a></h2><p>切片中元素的具体操作和数组的方式是一样的。如果获取元素时超出切片长度，即使没有超出容量，编译器也会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 设置索引 1 的元素为 4  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>4</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>1</span>])  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>4</span>  
</span></span></code></pre></div><h2 id=获取子集>获取子集<a hidden class=anchor aria-hidden=true href=#获取子集>#</a></h2><p>定义了一个切片或数组后，可以获取其中的一部分，即子集。</p><p>格式： <code>切片或数组[开始索引:结束索引]</code></p><p>获取从“开始索引”到“结束索引”的子集，<strong>包含开始索引，但不包含结束索引</strong>。如果是数组获取子集后，类型会转化为切片类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 切片  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取切片子集  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>]   <span style=color:#75715e>// []int{3, 4}  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 数组  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// nums2 为切片类型  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>]    <span style=color:#75715e>// []int{3, 4}  
</span></span></span></code></pre></div><h3 id=省略索引>省略索引<a hidden class=anchor aria-hidden=true href=#省略索引>#</a></h3><p>“开始索引”和“结束索引”都可以省略。</p><ul><li>开始索引省略，表示子集从索引 0 开始到结束索引。</li><li>结束索引省略，表示子集从开始索引到最后结束。</li><li>都省略，如果是切片两者一样，如果是数组会转化为切片类型。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 开始索引省略  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[:<span style=color:#ae81ff>3</span>] <span style=color:#75715e>// []int{1, 2, 3}  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 结束索引省略  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>2</span>:] <span style=color:#75715e>// []int{3, 4, 5}  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// nums3 和 nums 相同  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 等价于：nums3 := nums  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[:]  
</span></span></code></pre></div><p>如果代码中 <code>nums</code> 为数组，那 <code>nums[:]</code> 会将数组转化为切片。下来看看以上代码的原理图，这样会加深理解。</p><p><img loading=lazy src=/images/20231207161293.webp alt=20231207161293.webp></p><p>从图中可以看出所有的切片都指向同一个数组，这也说明了<strong>切片是一个引用类型</strong>，它在传递时不会进行拷贝。</p><h2 id=追加和移除元素>追加和移除元素<a hidden class=anchor aria-hidden=true href=#追加和移除元素>#</a></h2><p>往切片中追加元素，使用到 <code>append</code> 函数，此函数只能追加到切片末尾。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// collection/slice-append.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>2</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>]  
</span></span></code></pre></div><p>如果想追加到切片开头，没有原生的函数，使用 <code>append</code> 变向的实现，这种方式其实就是合并两个切片。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// collection/slice-append-front.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// ... 三个点表示将切片元素展开传递给函数  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> = append([]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>}, <span style=color:#a6e22e>nums</span><span style=color:#f92672>...</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]  
</span></span></code></pre></div><p>如何移除某个元素呢，使用切片子集和 <code>append</code> 函数变向实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// collection/slice-append-remove.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// 移除索引为 2 的元素值 3  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>[:<span style=color:#ae81ff>2</span>], <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>3</span>:]<span style=color:#f92672>...</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>]  
</span></span></code></pre></div><h2 id=切片拷贝>切片拷贝<a hidden class=anchor aria-hidden=true href=#切片拷贝>#</a></h2><h3 id=1-copy-函数>1. copy 函数<a hidden class=anchor aria-hidden=true href=#1-copy-函数>#</a></h3><p>从上面了解到切片是一个引用类型，因此不能像数组一样直接赋值给一个新变量就会产生拷贝。下来使用 <code>copy</code> 函数完成切片的拷贝。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// collection/slice-copy-1.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 将 nums 拷贝到 numsCopy   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>numsCopy</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>copy(<span style=color:#a6e22e>numsCopy</span>, <span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 修改了 numsCopy，不会对 nums 产生影响  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>numsCopy</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;nums:&#34;</span>, <span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;numsCopy:&#34;</span>, <span style=color:#a6e22e>numsCopy</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span>: [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>numsCopy</span>: [<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]  
</span></span></code></pre></div><p><code>numsCopy</code> 长度可以小于或大于 <code>nums</code> 的长度，如果小于就会拷贝 <code>nums</code> 前面一部分，大于会保留 <code>numsCopy</code> 后面一部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// collection/slice-copy-2.go  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// numsCopy 长度小于 nums  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>numsCopy</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>2</span>)  
</span></span><span style=display:flex><span><span style=color:#75715e>// 前面两个元素 1 和 2 被复制  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>copy(<span style=color:#a6e22e>numsCopy</span>, <span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;numsCopy(小于):&#34;</span>, <span style=color:#a6e22e>numsCopy</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// numsCopy 长度大于 nums  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>numsCopy</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>// 4,5,6 会被覆盖，保留 7  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>copy(<span style=color:#a6e22e>numsCopy</span>, <span style=color:#a6e22e>nums</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;numsCopy(大于):&#34;</span>, <span style=color:#a6e22e>numsCopy</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>numsCopy</span>(<span style=color:#960050;background-color:#1e0010>小于</span>): [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>numsCopy</span>(<span style=color:#960050;background-color:#1e0010>大于</span>): [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>7</span>]  
</span></span></code></pre></div><h3 id=2-长度--容量触发拷贝>2. “长度 > 容量”触发拷贝<a hidden class=anchor aria-hidden=true href=#2-长度--容量触发拷贝>#</a></h3><p>使用 <code>append</code> 函数给切片追加元素时，如果追加的长度大于切片的容量时，切片的底层数组空间则重新开辟一块比原来大的地方，并把原来的数组值拷贝一份。</p><p><img loading=lazy src=/images/20231207161299.webp alt=20231207161299.webp></p><p>注解：</p><ul><li>图中”新数组“两个位置就是切片长度大于容量的时刻，这两个时刻会自动开辟新数组，与原来的数组没有任何关联，只是把值拷贝了一份。</li><li>图中创建”新数组“时，容量的大小是原来的 2 倍，但这不是一成不变的，不同情况算法也会不一样，想要了解清楚我推荐一篇文章《<a href=https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA>深度解密Go语言之Slice</a>》。</li></ul><h2 id=多维切片>多维切片<a hidden class=anchor aria-hidden=true href=#多维切片>#</a></h2><p>这块和多维数组是类似的，唯一的不同点是切片没有指明长度，举个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 声明二维切片  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mult</span> [][]<span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 初始化二维切片  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>students</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{  
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>},  
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>},  
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>},  
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>},  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>注：如果想创建三维切片、四维切片，只要和多维数组类比就行。</p><h2 id=切片字符串>切片字符串<a hidden class=anchor aria-hidden=true href=#切片字符串>#</a></h2><p>这个是啥呢？是字符串可以使用上面的子集用法，来获取字符串中的一部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;I&#39;m laomiao.&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>str</span>[<span style=color:#ae81ff>4</span>:<span style=color:#ae81ff>7</span>])  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lao</span>  
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本篇围绕”切片“进行了重点讲解，在实际开发中也常常被使用，所以一定要掌握清楚。文中没有写明如何遍历切片，是因为它和数组的使用是一样的，如果不懂，请翻阅上篇文章。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.gby.ai/golang-map/><span class=title>« 上一页</span><br><span>Go基础系列：9. 内置集合 - map</span></a>
<a class=next href=https://www.gby.ai/golang-array/><span class=title>下一页 »</span><br><span>Go基础系列：7. 内置集合 - 数组</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：8. 内置集合 - 切片 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a8.%20%e5%86%85%e7%bd%ae%e9%9b%86%e5%90%88%20-%20%e5%88%87%e7%89%87&amp;url=https%3a%2f%2fwww.gby.ai%2fgolang-slice%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：8. 内置集合 - 切片 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a8.%20%e5%86%85%e7%bd%ae%e9%9b%86%e5%90%88%20-%20%e5%88%87%e7%89%87"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>