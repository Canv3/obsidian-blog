<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vercel 解决静态网站接口跨域 | PrintLove</title><meta name=keywords content><meta name=description content="当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。
所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？
说出来了当然有。
前提 使用 vercel 托管你的静态网站。
开始配置 1. vercel.json 在你的项目根目录创建一个 vercel.json 文件，内容如下：
{ &#34;rewrites&#34;: [ { &#34;source&#34;: &#34;/notion-api/(.*)&#34;, &#34;destination&#34;: &#34;/api/proxy&#34; } ] } •source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。
2. destination 这个地址是在 vercel 上启动一个常驻服务生成的。
在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：
// req：请求 // res：响应 module.exports = (req, res) => { // ... } 然后在这个函数体内可以自己编写请求的转发。
看看我的写过的一个例子，用来转发 Notion API 接口。
完整例子：
const request = require('request'); module.exports = (req, res) => { // proxy middleware options let prefix = &#34;/notion-api&#34; if (!"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.printlove.cn/vercel-cross/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Vercel 解决静态网站接口跨域"><meta property="og:description" content="当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。
所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？
说出来了当然有。
前提 使用 vercel 托管你的静态网站。
开始配置 1. vercel.json 在你的项目根目录创建一个 vercel.json 文件，内容如下：
{ &#34;rewrites&#34;: [ { &#34;source&#34;: &#34;/notion-api/(.*)&#34;, &#34;destination&#34;: &#34;/api/proxy&#34; } ] } •source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。
2. destination 这个地址是在 vercel 上启动一个常驻服务生成的。
在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：
// req：请求 // res：响应 module.exports = (req, res) => { // ... } 然后在这个函数体内可以自己编写请求的转发。
看看我的写过的一个例子，用来转发 Notion API 接口。
完整例子：
const request = require('request'); module.exports = (req, res) => { // proxy middleware options let prefix = &#34;/notion-api&#34; if (!"><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/vercel-cross/"><meta property="og:image" content="https://images.unsplash.com/photo-1549810029-947c46bc3a5c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyNHx8c3RhdGljfGVufDB8MHx8fDE3MDMzMzgzMjR8MA&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-19T21:20:31+08:00"><meta property="article:modified_time" content="2021-12-19T21:20:31+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1549810029-947c46bc3a5c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyNHx8c3RhdGljfGVufDB8MHx8fDE3MDMzMzgzMjR8MA&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Vercel 解决静态网站接口跨域"><meta name=twitter:description content="当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。
所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？
说出来了当然有。
前提 使用 vercel 托管你的静态网站。
开始配置 1. vercel.json 在你的项目根目录创建一个 vercel.json 文件，内容如下：
{ &#34;rewrites&#34;: [ { &#34;source&#34;: &#34;/notion-api/(.*)&#34;, &#34;destination&#34;: &#34;/api/proxy&#34; } ] } •source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。
2. destination 这个地址是在 vercel 上启动一个常驻服务生成的。
在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：
// req：请求 // res：响应 module.exports = (req, res) => { // ... } 然后在这个函数体内可以自己编写请求的转发。
看看我的写过的一个例子，用来转发 Notion API 接口。
完整例子：
const request = require('request'); module.exports = (req, res) => { // proxy middleware options let prefix = &#34;/notion-api&#34; if (!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Vercel 解决静态网站接口跨域","item":"https://www.printlove.cn/vercel-cross/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vercel 解决静态网站接口跨域","name":"Vercel 解决静态网站接口跨域","description":"当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。\n所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？\n说出来了当然有。\n前提 使用 vercel 托管你的静态网站。\n开始配置 1. vercel.json 在你的项目根目录创建一个 vercel.json 文件，内容如下：\n{ \u0026#34;rewrites\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;/notion-api/(.*)\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;/api/proxy\u0026#34; } ] } •source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。\n2. destination 这个地址是在 vercel 上启动一个常驻服务生成的。\n在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：\n// req：请求 // res：响应 module.exports = (req, res) =\u0026gt; { // ... } 然后在这个函数体内可以自己编写请求的转发。\n看看我的写过的一个例子，用来转发 Notion API 接口。\n完整例子：\nconst request = require(\u0026#39;request\u0026#39;); module.exports = (req, res) =\u0026gt; { // proxy middleware options let prefix = \u0026#34;/notion-api\u0026#34; if (!","keywords":[],"articleBody":"当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。\n所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？\n说出来了当然有。\n前提 使用 vercel 托管你的静态网站。\n开始配置 1. vercel.json 在你的项目根目录创建一个 vercel.json 文件，内容如下：\n{ \"rewrites\": [ { \"source\": \"/notion-api/(.*)\", \"destination\": \"/api/proxy\" } ] } •source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。\n2. destination 这个地址是在 vercel 上启动一个常驻服务生成的。\n在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：\n// req：请求 // res：响应 module.exports = (req, res) =\u003e { // ... } 然后在这个函数体内可以自己编写请求的转发。\n看看我的写过的一个例子，用来转发 Notion API 接口。\n完整例子：\nconst request = require('request'); module.exports = (req, res) =\u003e { // proxy middleware options let prefix = \"/notion-api\" if (!req.url.startsWith(prefix)) { return; } let target = \"https://api.notion.com\" + req.url.substring(prefix.length); var options = { 'method': 'GET', 'url': target, 'headers': { 'Notion-Version': res.headers['notion-version'], 'Authorization': res.headers['authorization'] } }; request(options, function (error, response) { if (error) throw new Error(error); res.writeHead(200, {\"Content-Type\": \"application/json\"}); res.write(response.body); res.end(); }); } 该例子，就是从 req 参数里获取想要的数据，然后使用 request 发放进行转发。\n2. Functions 写好后，如何运行这个文件呢？\n在 Vercel 后台找到 Functions 这个功能板块，如果上面的配置没有问题，并且已经重新部署，那么就会出现如下图：\n配置好后，就可以测试了。\n假如我的静态网站在 Vercel 上的地址是 https://laomiao.site，那么根据 version.json 文件中的配置访问：\nhttps://laomiao.site/notion-api/xxxxxxx\n成功后会在 Functions 页面出现访问日志，如果没有那就说明有问题。\n总结 我捋下流程。\n","wordCount":"148","inLanguage":"zh","image":"https://images.unsplash.com/photo-1549810029-947c46bc3a5c?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyNHx8c3RhdGljfGVufDB8MHx8fDE3MDMzMzgzMjR8MA\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-12-19T21:20:31+08:00","dateModified":"2021-12-19T21:20:31+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/vercel-cross/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Vercel 解决静态网站接口跨域</h1><div class=post-meta><span title='2021-12-19 21:20:31 +0800 CST'>2021-12-19</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Vercel%20%e8%a7%a3%e5%86%b3%e9%9d%99%e6%80%81%e7%bd%91%e7%ab%99%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前提>前提</a></li><li><a href=#开始配置>开始配置</a><ul><li><a href=#1-verceljson>1. vercel.json</a></li><li><a href=#2-destination>2. destination</a></li><li><a href=#2-functions>2. Functions</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><p>当你的站是一个静态网站时，并且网站中有接口请求时，可能会出现跨域问题。那解决该问题的大部分的办法就是使用一个服务器做代理转发。</p><p>所以说到这就知道，还需要一个服务器，即：要花钱。那有什么办法吗？</p><p>说出来了当然有。</p><h2 id=前提>前提<a hidden class=anchor aria-hidden=true href=#前提>#</a></h2><p>使用 vercel 托管你的静态网站。</p><h2 id=开始配置>开始配置<a hidden class=anchor aria-hidden=true href=#开始配置>#</a></h2><h3 id=1-verceljson>1. vercel.json<a hidden class=anchor aria-hidden=true href=#1-verceljson>#</a></h3><p>在你的项目根目录创建一个 vercel.json 文件，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;rewrites&#34;</span>: [  
</span></span><span style=display:flex><span>        {  
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;source&#34;</span>: <span style=color:#e6db74>&#34;/notion-api/(.*)&#34;</span>,  
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;destination&#34;</span>: <span style=color:#e6db74>&#34;/api/proxy&#34;</span>  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    ]  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>•source：不直接请求接口地址，而是按照 source 格式的方式访问，该格式自己定义。•destination：将 source 匹配到的 url 转发到 destination 地址上。</p><h3 id=2-destination>2. destination<a hidden class=anchor aria-hidden=true href=#2-destination>#</a></h3><p>这个地址是在 vercel 上启动一个常驻服务生成的。</p><p>在项目根目录创建一个 api/proxy.js 路径的文件，按照这个路径要求来，该文件的内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// req：请求  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// res：响应  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><p>然后在这个函数体内可以自己编写请求的转发。</p><p>看看我的写过的一个例子，用来转发 Notion API 接口。</p><p>完整例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;request&#39;</span>);  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// proxy middleware options  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>prefix</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/notion-api&#34;</span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#a6e22e>prefix</span>)) {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;  
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://api.notion.com&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>prefix</span>.<span style=color:#a6e22e>length</span>);  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>options</span> <span style=color:#f92672>=</span> {  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;method&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;GET&#39;</span>,  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;url&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>target</span>,  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;headers&#39;</span><span style=color:#f92672>:</span> {  
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;Notion-Version&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>headers</span>[<span style=color:#e6db74>&#39;notion-version&#39;</span>],  
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;Authorization&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>headers</span>[<span style=color:#e6db74>&#39;authorization&#39;</span>]  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  };  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>request</span>(<span style=color:#a6e22e>options</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>response</span>) {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>error</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#a6e22e>error</span>);  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>writeHead</span>(<span style=color:#ae81ff>200</span>, {<span style=color:#e6db74>&#34;Content-Type&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;application/json&#34;</span>});  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>body</span>);  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>end</span>();  
</span></span><span style=display:flex><span>  });  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>该例子，就是从 req 参数里获取想要的数据，然后使用 request 发放进行转发。</p><h3 id=2-functions>2. Functions<a hidden class=anchor aria-hidden=true href=#2-functions>#</a></h3><p>写好后，如何运行这个文件呢？</p><p>在 Vercel 后台找到 Functions 这个功能板块，如果上面的配置没有问题，并且已经重新部署，那么就会出现如下图：</p><p><img loading=lazy src=/images/096396f727dafb34f78d86af313214b4.webp alt></p><p>配置好后，就可以测试了。</p><p>假如我的静态网站在 Vercel 上的地址是 <a href=https://laomiao.site>https://laomiao.site</a>，那么根据 version.json 文件中的配置访问：</p><p><a href=https://laomiao.site/notion-api/xxxxxxx>https://laomiao.site/notion-api/xxxxxxx</a></p><p>成功后会在 Functions 页面出现访问日志，如果没有那就说明有问题。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>我捋下流程。</p><p><img loading=lazy src=/images/ac23066af80b695b9dab31a045d93c2f.webp alt></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/ubuntu-cfw/><span class=title>« 上一页</span><br><span>2022 科学上网 Ubuntu & CFW 实现透明代理</span></a>
<a class=next href=https://www.printlove.cn/vercel-notion/><span class=title>下一页 »</span><br><span>Vercel + Notion 建个人博客</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Vercel 解决静态网站接口跨域 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Vercel%20%e8%a7%a3%e5%86%b3%e9%9d%99%e6%80%81%e7%bd%91%e7%ab%99%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f&amp;url=https%3a%2f%2fwww.printlove.cn%2fvercel-cross%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Vercel 解决静态网站接口跨域 on email" href="mailto:mglluoye@gmail.com?subject=Vercel%20%e8%a7%a3%e5%86%b3%e9%9d%99%e6%80%81%e7%bd%91%e7%ab%99%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>