<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker的cgroup讲解 | PrintLove</title><meta name=keywords content><meta name=description content="最近在看一个微服务框架 github.com/tal-tech/go-zero，在 core/stat/internal 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。
概念 cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。官方解释
subsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。
hierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。
cgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。
对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。
如果未理解跳过往下看，回头再看
讲解 /proc/[pid]/cgroup 进程的 cgroup 信息，如下图：
每行的格式 hierarchy-ID:controller-list:cgroup-path，此截图中 cgroup-path 对应的容器 id /sys/fs/cgroup/ 目录 cpuacct/cpuacct.usage_percpu 每个 cpu 的使用时间，如下图："><meta name=author content="Evan Miao"><link rel=canonical href=https://www.jianshu.com/p/aa4282c4ae58><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.printlove.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.printlove.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.printlove.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.printlove.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.printlove.cn/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker的cgroup讲解"><meta property="og:description" content="最近在看一个微服务框架 github.com/tal-tech/go-zero，在 core/stat/internal 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。
概念 cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。官方解释
subsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。
hierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。
cgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。
对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。
如果未理解跳过往下看，回头再看
讲解 /proc/[pid]/cgroup 进程的 cgroup 信息，如下图：
每行的格式 hierarchy-ID:controller-list:cgroup-path，此截图中 cgroup-path 对应的容器 id /sys/fs/cgroup/ 目录 cpuacct/cpuacct.usage_percpu 每个 cpu 的使用时间，如下图："><meta property="og:type" content="article"><meta property="og:url" content="https://www.printlove.cn/docker-cgroup/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-14T11:06:39+08:00"><meta property="article:modified_time" content="2021-01-14T11:06:39+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker的cgroup讲解"><meta name=twitter:description content="最近在看一个微服务框架 github.com/tal-tech/go-zero，在 core/stat/internal 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。
概念 cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。官方解释
subsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。
hierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。
cgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。
对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。
如果未理解跳过往下看，回头再看
讲解 /proc/[pid]/cgroup 进程的 cgroup 信息，如下图：
每行的格式 hierarchy-ID:controller-list:cgroup-path，此截图中 cgroup-path 对应的容器 id /sys/fs/cgroup/ 目录 cpuacct/cpuacct.usage_percpu 每个 cpu 的使用时间，如下图："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.printlove.cn/posts/"},{"@type":"ListItem","position":2,"name":"Docker的cgroup讲解","item":"https://www.printlove.cn/docker-cgroup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker的cgroup讲解","name":"Docker的cgroup讲解","description":"最近在看一个微服务框架 github.com/tal-tech/go-zero，在 core/stat/internal 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。\n概念 cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。官方解释\nsubsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\nhierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。\ncgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。\n对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。\n如果未理解跳过往下看，回头再看\n讲解 /proc/[pid]/cgroup 进程的 cgroup 信息，如下图：\n每行的格式 hierarchy-ID:controller-list:cgroup-path，此截图中 cgroup-path 对应的容器 id /sys/fs/cgroup/ 目录 cpuacct/cpuacct.usage_percpu 每个 cpu 的使用时间，如下图：","keywords":[],"articleBody":"最近在看一个微服务框架 github.com/tal-tech/go-zero，在 core/stat/internal 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。\n概念 cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。官方解释\nsubsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\nhierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。\ncgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。\n对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。\n如果未理解跳过往下看，回头再看\n讲解 /proc/[pid]/cgroup 进程的 cgroup 信息，如下图：\n每行的格式 hierarchy-ID:controller-list:cgroup-path，此截图中 cgroup-path 对应的容器 id /sys/fs/cgroup/ 目录 cpuacct/cpuacct.usage_percpu 每个 cpu 的使用时间，如下图：\ncpuset/cpuset.cpuscpu 列表，如下图（我的电脑是 4 核）：\ncpu/cpu.cfs_period_us 时间周期\ncpu/cpu.cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数，两个文件配合起来设置 CPU 的使用上限。两个文件的单位都是微秒（us），cfs_period_us 的取值范围为 1 毫秒（ms）到 1 秒（s），cfs_quota_us 的取值大于 1ms 即可，如果 cfs_quota_us 的值为 -1（默认值），表示不受 cpu 时间的限制。\ncpuacct/cpuacct.usage 统计这个 cgroup 中所有任务消耗的总 cpu 时间（纳秒）\n附加：/proc/stat 该文件包含了所有 CPU 活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻，如下图：\n第一行代表总的 cpu 时间，单位是 jiffies，jiffies 是内核中的一个全局变量，用来记录自系统启动一来产生的节拍数，在 linux 中，一个节拍大致可理解为操作系统进程调度的最小时间片，不同 linux 内核可能值有不同，通常在 1ms 到 10ms 之间。\n","wordCount":"123","inLanguage":"zh","datePublished":"2021-01-14T11:06:39+08:00","dateModified":"2021-01-14T11:06:39+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.printlove.cn/docker-cgroup/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.printlove.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.printlove.cn/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.printlove.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.printlove.cn/series title=系列><span>系列</span></a></li><li><a href=https://www.printlove.cn/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker的cgroup讲解</h1><div class=post-meta><span title='2021-01-14 11:06:39 +0800 CST'>2021-01-14</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Docker%e7%9a%84cgroup%e8%ae%b2%e8%a7%a3.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#概念>概念</a></li><li><a href=#讲解>讲解</a></li></ul></nav></div></details></div><div class=post-content><p>最近在看一个微服务框架 <code>github.com/tal-tech/go-zero</code>，在 <code>core/stat/internal</code> 目录下学习到 cgroup 知识，本文只涉及到了我所学习到的，正文开始。</p><hr><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup 绑定一个进程集合到一个或多个子系统上。<a href=https://man7.org/linux/man-pages/man7/cgroups.7.html>官方解释</a></p><ul><li><p>subsystem，子系统，一个通过 cgroup 提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p></li><li><p>hierarchy，层级树，多个 cgroup 的集合，这些集合构成的树叫 hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy 上的层次关系通过 cgroupfs 虚拟文件系统显示。系统允许多个 hierarchy 同时存在，每个 hierachy 包含系统中的部分或者全部进程集合。</p></li><li><p>cgroupfs 是用户管理操纵 cgroup 的主要接口：通过在 cgroupfs 文件系统中创建目录，实现 cgroup 的创建；通过向目录下的属性文件写入内容，设置 cgroup 对资源的控制；向 task 属性文件写入进程 ID，可以将进程绑定到某个 cgroup，以此达到控制进程资源使用的目的；也可以列出 cgroup 包含的进程 pid。这些操作影响的是 sysfs 关联的 hierarchy，对其它 hierarchy 没有影响。</p></li></ul><p>对于 cgroup，其本身的作用只是任务跟踪。但其它系统（比如 cpusets，cpuacct），可以利用 cgroup 的这个功能实现一些新的属性，比如统计或者控制一个 cgroup 中进程可以访问的资源。举个例子，cpusets 子系统可以将进程绑定到特定的 cpu 和内存节点上。</p><p><em><strong>如果未理解跳过往下看，回头再看</strong></em></p><h2 id=讲解>讲解<a hidden class=anchor aria-hidden=true href=#讲解>#</a></h2><ol><li><code>/proc/[pid]/cgroup</code> 进程的 cgroup 信息，如下图：<br><img loading=lazy src=/images/f31a639541b3609f02a2ccfee1fe9dc4.webp alt></li></ol><ul><li>每行的格式 <code>hierarchy-ID:controller-list:cgroup-path</code>，此截图中 cgroup-path 对应的容器 id</li></ul><ol start=2><li><code>/sys/fs/cgroup/</code> 目录</li></ol><ul><li><p><code>cpuacct/cpuacct.usage_percpu</code> 每个 cpu 的使用时间，如下图：<br><img loading=lazy src=/images/a8210184ed421e07a86eb59180cf5bc8.webp alt=cpuacct.usage_percpu></p></li><li><p><code>cpuset/cpuset.cpus</code>cpu 列表，如下图（我的电脑是 4 核）：<br><img loading=lazy src=/images/9958ef1c6dedf4603eb92d67dcfc90b0.webp alt=cpuset.cpus></p></li><li><p><code>cpu/cpu.cfs_period_us</code> 时间周期</p></li><li><p><code>cpu/cpu.cfs_quota_us</code> 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数，两个文件配合起来设置 CPU 的使用上限。两个文件的单位都是微秒（us），cfs_period_us 的取值范围为 1 毫秒（ms）到 1 秒（s），cfs_quota_us 的取值大于 1ms 即可，如果 cfs_quota_us 的值为 -1（默认值），表示不受 cpu 时间的限制。</p></li><li><p><code>cpuacct/cpuacct.usage</code> 统计这个 cgroup 中所有任务消耗的总 cpu 时间（纳秒）<br><img loading=lazy src=/images/8aa37b51455ad3c7d5ed5512972a1d3c.webp alt=cpuacct/cpuacct.usage></p></li></ul><ol start=3><li><strong>附加：</strong><code>/proc/stat</code> 该文件包含了所有 CPU 活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻，如下图：<br><img loading=lazy src=/images/3667b10b75fca213d005efb184f53561.webp alt=/proc/stat></li></ol><p>第一行代表总的 cpu 时间，单位是 jiffies，jiffies 是内核中的一个全局变量，用来记录自系统启动一来产生的节拍数，在 linux 中，一个节拍大致可理解为操作系统进程调度的最小时间片，不同 linux 内核可能值有不同，通常在 1ms 到 10ms 之间。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.printlove.cn/tomato/><span class=title>« 上一页</span><br><span>“番茄工作法”你确定了解吗？</span></a>
<a class=next href=https://www.printlove.cn/supervisor/><span class=title>下一页 »</span><br><span>supervisor(进程管理)小白快速上手</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker的cgroup讲解 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Docker%e7%9a%84cgroup%e8%ae%b2%e8%a7%a3&amp;url=https%3a%2f%2fwww.printlove.cn%2fdocker-cgroup%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker的cgroup讲解 on email" href="mailto:mglluoye@gmail.com?subject=Docker%e7%9a%84cgroup%e8%ae%b2%e8%a7%a3"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>