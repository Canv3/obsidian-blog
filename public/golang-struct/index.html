<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础系列：12. 自定义类型和结构体 - 定义 | PrintLove</title><meta name=keywords content="Go,结构体"><meta name=description content="自定义类型、结构体定义、匿名结构体、类型别名"><meta name=author content="Evan Miao"><link rel=canonical href=https://www.gby.ai/golang-struct/><link crossorigin=anonymous href=/assets/css/stylesheet.0f4d06feb7a00553d7b46603ca44aaca1dd036cd7082d6cecf39137242c0cb9e.css integrity="sha256-D00G/regBVPXtGYDykSqyh3QNs1wgtbOzzkTckLAy54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.gby.ai/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gby.ai/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gby.ai/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gby.ai/apple-touch-icon.png><link rel=mask-icon href=https://www.gby.ai/safari_pinned_tab.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4bddc7ae6f2203e19017f349bdcc79c2",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-VE0D4BXTS2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VE0D4BXTS2",{anonymize_ip:!1})}</script><meta property="og:title" content="Go基础系列：12. 自定义类型和结构体 - 定义"><meta property="og:description" content="自定义类型、结构体定义、匿名结构体、类型别名"><meta property="og:type" content="article"><meta property="og:url" content="https://www.gby.ai/golang-struct/"><meta property="og:image" content="https://images.unsplash.com/photo-1535384515441-5a7293014fce?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyODB8fHR5cGV8ZW58MHwwfHx8MTcwMzMwMjQ1OHww&ixlib=rb-4.0.3&q=80&w=400"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-07T18:30:56+08:00"><meta property="article:modified_time" content="2021-09-07T18:30:56+08:00"><meta property="og:site_name" content="PrintLove"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1535384515441-5a7293014fce?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyODB8fHR5cGV8ZW58MHwwfHx8MTcwMzMwMjQ1OHww&ixlib=rb-4.0.3&q=80&w=400"><meta name=twitter:title content="Go基础系列：12. 自定义类型和结构体 - 定义"><meta name=twitter:description content="自定义类型、结构体定义、匿名结构体、类型别名"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gby.ai/posts/"},{"@type":"ListItem","position":2,"name":"Go基础系列：12. 自定义类型和结构体 - 定义","item":"https://www.gby.ai/golang-struct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础系列：12. 自定义类型和结构体 - 定义","name":"Go基础系列：12. 自定义类型和结构体 - 定义","description":"自定义类型、结构体定义、匿名结构体、类型别名","keywords":["Go","结构体"],"articleBody":"学到什么 如何自定义类型？ 如何定义结构体？ 如何初始化结构体？ 如何嵌套结构体？ 如何定义匿名结构体？ 如何给类型取别名？ 如何定义结构体标签？ 概念 什么是自定义类型？当 Go 语言中内置的类型，例如：int、string 等等，不能满足需求时，就可以自定义一个类型。\n创建自定义类型 1. 基于内置类型 type typeName baseType typeName 为定义的类型名称 baseType 依赖的类型，Go 语言中所有的数据类型都可以，还有待会要讲的结构体 struct 举例，以下 3 个自定义的类型都依赖于内置类型。\ntype str string type num int type m map[string]string 在上例中，虽然 str 类型依赖 string 类型，但在 Go 语言中是强类型语言，也就是这两个类型不能直接比较。\n如果 str 和 string 类型相比较，就需要类型转化，自定义的其它类型都是这样。\nvar s1 str = \"new string\" // str 转化为 string 类型 s2 := string(s1) 2. 结构体 结构体是自定义类型中的复合类型，在这个类型中可以包含多个不同的数据类型。\n定义了一个 People 类型的结构体，里面包含了两个类型字段。\ntype People struct { // 字段 *Name string* Age int } 当字段类型相同时，可以对相同的只声明一次。\ntype StructName struct { Name string Age, Weight int } 如果想把结构体中的字段写在一行，需要使用 \" 英文分号 \" 相隔，为了代码的结构清晰，这种一般不使用。\ntype OneLine struct{Name string; Age, Weight int} 结构体中也可以不定义任何字段，即空结构体。\ntype EmptyStruct struct {} 注意点：\n使用 struct 关键字定义。 struct 关键字后必须紧跟 “{”，即在同一行。 初始化结构体 定义好结构体后，下来就需要初始化值。\n1. 带字段名称 p1 := People{ Name: \"老苗\", Age: 18, } 给字段赋值时，也可以只设置一部分，也可以都不设置，没有设置的会按照默认值走。\np := People{ Age: 18, } exmaple := People{} Name 默认为空字符串，Age 默认为 0。\n2. 不带字段名称 在设置字段值时，可以不带字段名称，这时候就必须按照结构体字段顺序赋值。\np2 := People{ \"老苗\", 18, } 赋值时，不能进行部分省略。 带字段名称和不带字段名称不能混合。 访问结构体字段 使用“点”访问字段值和设置字段值\np := People{\"老苗\", 18} // 访问字段 fmt.Println(p.Name) // 设置字段 p.Name = \"潇洒哥\" 结构体嵌套 在一个结构体中，可以嵌套另外一个结构体。这个特性在面向对象中，有点类似继承。\ntype People struct { Name string Age int } type Student struct { People Collect string } 在 Student 结构体中，嵌套了 People 结构体。嵌套时，可以不需要设置字段名称，这时候默认的字段名称为嵌套类型名称。\n1. 初始化 使用两种方式初始化 Student 结构体，一种是带字段名称，另一种是不带字段名称。\n// 第一种：带字段名称 s1 := Student{ People: People{ Name: \"老苗\", Age: 18, }, Collect: \"不告诉\", } // 第二种：不带字段名称 s2 := Student{ People{ Name: \"老苗\", Age: 18, }, \"不告诉\", } 2. 访问嵌套结构体 在上面的例子中，People 结构体嵌入到 Student 结构体中，并且没有定义字段名称，这种情况获取 People 结构体中的字段就有两种方式。\n第一种：访问不带字段名称，因为 People 和 Student 结构体中的字段会变成同一级，结构体携带的方法（下篇讲解）也是一样。\ns2.Name 第二种：访问带字段名称，嵌入时不写字段名称，默认的字段名称就是嵌入类型名。\ns2.People.Name 3. 字段名相同 当被嵌入结构体与父级结构体字段名称相同时，编译器是可以通过的。例如 RepeatStudent 结构体中的 Name 字段与 People 结构体中的 Name 字段名相同，这时候访问 People 结构体中的 Name 字段就必须带上结构体名称。\ntype RepeatStudent struct { People Collect string Name string } r := RepeatStudent{ People: People{Name: \"老苗\"}, Name: \"潇洒哥\", } fmt.Println(r.Name, r.People.Name) // 输出 潇洒哥 老苗 匿名结构体 匿名结构体指的就是没有结构体名称，和匿名函数一样都没有名称。\nano := struct { Name string }{ Name: \"匿名\", } 该代码定义了一个匿名结构体并包含了一个字段，定义后再进行初始化。\n在嵌套结构体时，也可以使用匿名结构体。\ntype AnoStudent struct { People struct { Name string Age int } Collect string } 结构体标签 在定义结构体时，可以给字段写上标签，通过标签对结构体的进行自定义处理。\n例如，使用标准包 \"encoding/json\" 转 json 字符串，通过标签可以声明将结构体字段转成对应的名称。\ntype Tag struct { Name string `json:\"name\"` } t := Tag{\"tag\"} b, _ := json.Marshal(t) fmt.Println(string(b)) // 输出 {\"name\":\"tag\"} 使用反引号包裹标签，标签的规则要看处理方法或函数是如何定义的。如何获取标签，这里不做讲解。\n类型别名 这个和自定义类型是不一样的，类型别名和原类型是完全等价的，不需要类型转化，只是名称不一样而已。\ntype byte = uint8 在内置类型中，byte 类型就是 uint8 类型的别名。\n总结 本篇讲解了如何自定义类型，并且对结构体详细的展开说明，千万要掌握，但还没有讲完，下篇讲解自定义类型如何携带方法。\n当你学习过面向对象的语言知道了类的概念后，下来我将类和结构体的相似之处对比下。\n类的属性 —- 结构体字段 类的方法 —- 结构体方法（下篇讲解） 类的继承 —- 结构体嵌套 这也是在改造面向对象的语言时，Go 语言的结构体被作为类的替代。\n","wordCount":"359","inLanguage":"zh","image":"https://images.unsplash.com/photo-1535384515441-5a7293014fce?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwyODB8fHR5cGV8ZW58MHwwfHx8MTcwMzMwMjQ1OHww\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=400","datePublished":"2021-09-07T18:30:56+08:00","dateModified":"2021-09-07T18:30:56+08:00","author":[{"@type":"Person","name":"Evan Miao"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gby.ai/golang-struct/"},"publisher":{"@type":"Organization","name":"PrintLove","logo":{"@type":"ImageObject","url":"https://www.gby.ai/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gby.ai/ accesskey=h title="PrintLove (Alt + H)">PrintLove</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gby.ai/archives title=文章><span>文章</span></a></li><li><a href=https://www.gby.ai/series title=系列><span>系列</span></a></li><li><a href=https://www.gby.ai/sponsor title=赞助><span>赞助</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go基础系列：12. 自定义类型和结构体 - 定义</h1><div class=post-meta><span title='2021-09-07 18:30:56 +0800 CST'>2021-09-07</span>&nbsp;·&nbsp;Evan Miao&nbsp;|&nbsp;<a href=https://github.com/miaogaolin/workspace-obisidian-publisher/tree/main/content/posts/Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a12.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e5%ae%9a%e4%b9%89.md rel="noopener noreferrer" target=_blank>指出问题</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#学到什么>学到什么</a></li><li><a href=#概念>概念</a></li><li><a href=#创建自定义类型>创建自定义类型</a><ul><li><a href=#1-基于内置类型>1. 基于内置类型</a></li><li><a href=#2-结构体>2. 结构体</a></li></ul></li><li><a href=#初始化结构体>初始化结构体</a><ul><li><a href=#1-带字段名称>1. 带字段名称</a></li><li><a href=#2-不带字段名称>2. 不带字段名称</a></li></ul></li><li><a href=#访问结构体字段>访问结构体字段</a></li><li><a href=#结构体嵌套>结构体嵌套</a><ul><li><a href=#1-初始化>1. 初始化</a></li><li><a href=#2-访问嵌套结构体>2. 访问嵌套结构体</a></li><li><a href=#3-字段名相同>3. 字段名相同</a></li></ul></li><li><a href=#匿名结构体>匿名结构体</a></li><li><a href=#结构体标签>结构体标签</a></li><li><a href=#类型别名>类型别名</a></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h2 id=学到什么>学到什么<a hidden class=anchor aria-hidden=true href=#学到什么>#</a></h2><ol><li>如何自定义类型？</li><li>如何定义结构体？</li><li>如何初始化结构体？</li><li>如何嵌套结构体？</li><li>如何定义匿名结构体？</li><li>如何给类型取别名？</li><li>如何定义结构体标签？</li></ol><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><p>什么是自定义类型？当 Go 语言中内置的类型，例如：int、string 等等，不能满足需求时，就可以自定义一个类型。</p><h2 id=创建自定义类型>创建自定义类型<a hidden class=anchor aria-hidden=true href=#创建自定义类型>#</a></h2><h3 id=1-基于内置类型>1. 基于内置类型<a hidden class=anchor aria-hidden=true href=#1-基于内置类型>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>typeName</span> <span style=color:#a6e22e>baseType</span>  
</span></span></code></pre></div><ul><li>typeName 为定义的类型名称</li><li>baseType 依赖的类型，Go 语言中所有的数据类型都可以，还有待会要讲的结构体 <code>struct</code></li></ul><p>举例，以下 3 个自定义的类型都依赖于内置类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>str</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>  
</span></span></code></pre></div><p>在上例中，虽然 <code>str</code> 类型依赖 <code>string</code> 类型，但在 Go 语言中是强类型语言，也就是这两个类型不能直接比较。</p><p>如果 <code>str</code> 和 <code>string</code> 类型相比较，就需要类型转化，自定义的其它类型都是这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> <span style=color:#a6e22e>str</span> = <span style=color:#e6db74>&#34;new string&#34;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// str 转化为 string 类型  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> string(<span style=color:#a6e22e>s1</span>)  
</span></span></code></pre></div><h3 id=2-结构体>2. 结构体<a hidden class=anchor aria-hidden=true href=#2-结构体>#</a></h3><p>结构体是自定义类型中的复合类型，在这个类型中可以包含多个不同的数据类型。</p><p>定义了一个 <code>People</code> 类型的结构体，里面包含了两个类型字段。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 字段  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>*</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>当字段类型相同时，可以对相同的只声明一次。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StructName</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>, <span style=color:#a6e22e>Weight</span> <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>如果想把结构体中的字段写在一行，需要使用 " 英文分号 " 相隔，为了代码的结构清晰，这种一般不使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>OneLine</span> <span style=color:#66d9ef>struct</span>{<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>; <span style=color:#a6e22e>Age</span>, <span style=color:#a6e22e>Weight</span> <span style=color:#66d9ef>int</span>}  
</span></span></code></pre></div><p>结构体中也可以不定义任何字段，即空结构体。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>EmptyStruct</span> <span style=color:#66d9ef>struct</span> {}  
</span></span></code></pre></div><p>注意点：</p><ul><li>使用 struct 关键字定义。</li><li>struct 关键字后必须紧跟 “{”，即在同一行。</li></ul><h2 id=初始化结构体>初始化结构体<a hidden class=anchor aria-hidden=true href=#初始化结构体>#</a></h2><p>定义好结构体后，下来就需要初始化值。</p><h3 id=1-带字段名称>1. 带字段名称<a hidden class=anchor aria-hidden=true href=#1-带字段名称>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;老苗&#34;</span>,  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>:  <span style=color:#ae81ff>18</span>,  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>给字段赋值时，也可以只设置一部分，也可以都不设置，没有设置的会按照默认值走。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>:  <span style=color:#ae81ff>18</span>,  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>exmaple</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{}  
</span></span></code></pre></div><p><code>Name</code> 默认为空字符串，<code>Age</code> 默认为 0。</p><h3 id=2-不带字段名称>2. 不带字段名称<a hidden class=anchor aria-hidden=true href=#2-不带字段名称>#</a></h3><p>在设置字段值时，可以不带字段名称，这时候就必须按照结构体字段顺序赋值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;老苗&#34;</span>,  
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>18</span>,  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li>赋值时，不能进行部分省略。</li><li>带字段名称和不带字段名称不能混合。</li></ul><h2 id=访问结构体字段>访问结构体字段<a hidden class=anchor aria-hidden=true href=#访问结构体字段>#</a></h2><p>使用“点”访问字段值和设置字段值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>People</span>{<span style=color:#e6db74>&#34;老苗&#34;</span>, <span style=color:#ae81ff>18</span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 访问字段  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 设置字段  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#e6db74>&#34;潇洒哥&#34;</span>  
</span></span></code></pre></div><h2 id=结构体嵌套>结构体嵌套<a hidden class=anchor aria-hidden=true href=#结构体嵌套>#</a></h2><p>在一个结构体中，可以嵌套另外一个结构体。这个特性在面向对象中，有点类似继承。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Collect</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>在 <code>Student</code> 结构体中，嵌套了 <code>People</code> 结构体。嵌套时，可以不需要设置字段名称，这时候默认的字段名称为嵌套类型名称。</p><h3 id=1-初始化>1. 初始化<a hidden class=anchor aria-hidden=true href=#1-初始化>#</a></h3><p>使用两种方式初始化 <code>Student</code> 结构体，一种是带字段名称，另一种是不带字段名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第一种：带字段名称  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Student</span>{  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span>: <span style=color:#a6e22e>People</span>{  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;老苗&#34;</span>,  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Age</span>:  <span style=color:#ae81ff>18</span>,  
</span></span><span style=display:flex><span>	},  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Collect</span>: <span style=color:#e6db74>&#34;不告诉&#34;</span>,  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 第二种：不带字段名称  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Student</span>{  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span>{  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;老苗&#34;</span>,  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Age</span>:  <span style=color:#ae81ff>18</span>,  
</span></span><span style=display:flex><span>	},  
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;不告诉&#34;</span>,  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h3 id=2-访问嵌套结构体>2. 访问嵌套结构体<a hidden class=anchor aria-hidden=true href=#2-访问嵌套结构体>#</a></h3><p>在上面的例子中，<code>People</code> 结构体嵌入到 <code>Student</code> 结构体中，并且没有定义字段名称，这种情况获取 <code>People</code> 结构体中的字段就有两种方式。</p><p>第一种：访问不带字段名称，因为 <code>People</code> 和 <code>Student</code> 结构体中的字段会变成同一级，结构体携带的方法（下篇讲解）也是一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s2</span>.<span style=color:#a6e22e>Name</span>  
</span></span></code></pre></div><p>第二种：访问带字段名称，嵌入时不写字段名称，默认的字段名称就是嵌入类型名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s2</span>.<span style=color:#a6e22e>People</span>.<span style=color:#a6e22e>Name</span>  
</span></span></code></pre></div><h3 id=3-字段名相同>3. 字段名相同<a hidden class=anchor aria-hidden=true href=#3-字段名相同>#</a></h3><p>当被嵌入结构体与父级结构体字段名称相同时，编译器是可以通过的。例如 <code>RepeatStudent</code> 结构体中的 <code>Name</code> 字段与 <code>People</code> 结构体中的 <code>Name</code> 字段名相同，这时候访问 <code>People</code> 结构体中的 <code>Name</code> 字段就必须带上结构体名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RepeatStudent</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Collect</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RepeatStudent</span>{  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span>: <span style=color:#a6e22e>People</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;老苗&#34;</span>},  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>:   <span style=color:#e6db74>&#34;潇洒哥&#34;</span>,  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>People</span>.<span style=color:#a6e22e>Name</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>潇洒哥</span> <span style=color:#960050;background-color:#1e0010>老苗</span>  
</span></span></code></pre></div><h2 id=匿名结构体>匿名结构体<a hidden class=anchor aria-hidden=true href=#匿名结构体>#</a></h2><p>匿名结构体指的就是没有结构体名称，和匿名函数一样都没有名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ano</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}{  
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;匿名&#34;</span>,  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>该代码定义了一个匿名结构体并包含了一个字段，定义后再进行初始化。</p><p>在嵌套结构体时，也可以使用匿名结构体。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AnoStudent</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>People</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Collect</span> <span style=color:#66d9ef>string</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h2 id=结构体标签>结构体标签<a hidden class=anchor aria-hidden=true href=#结构体标签>#</a></h2><p>在定义结构体时，可以给字段写上标签，通过标签对结构体的进行自定义处理。</p><p>例如，使用标准包 "encoding/json" 转 json 字符串，通过标签可以声明将结构体字段转成对应的名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tag</span> <span style=color:#66d9ef>struct</span> {  
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Tag</span>{<span style=color:#e6db74>&#34;tag&#34;</span>}  
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>t</span>)  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>b</span>))  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;tag&#34;</span>}  
</span></span></code></pre></div><p>使用反引号包裹标签，标签的规则要看处理方法或函数是如何定义的。如何获取标签，这里不做讲解。</p><h2 id=类型别名>类型别名<a hidden class=anchor aria-hidden=true href=#类型别名>#</a></h2><p>这个和自定义类型是不一样的，类型别名和原类型是完全等价的，不需要类型转化，只是名称不一样而已。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>byte</span> = <span style=color:#66d9ef>uint8</span>  
</span></span></code></pre></div><p>在内置类型中，<code>byte</code> 类型就是 <code>uint8</code> 类型的别名。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本篇讲解了如何自定义类型，并且对结构体详细的展开说明，千万要掌握，但还没有讲完，下篇讲解自定义类型如何携带方法。</p><p>当你学习过面向对象的语言知道了类的概念后，下来我将类和结构体的相似之处对比下。</p><ul><li>类的属性 —- 结构体字段</li><li>类的方法 —- 结构体方法（下篇讲解）</li><li>类的继承 —- 结构体嵌套</li></ul><p>这也是在改造面向对象的语言时，Go 语言的结构体被作为类的替代。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.gby.ai/golang-method/><span class=title>« 上一页</span><br><span>Go基础系列：13. 自定义类型和结构体 - 方法</span></a>
<a class=next href=https://www.gby.ai/golang-package/><span class=title>下一页 »</span><br><span>Go基础系列：11. 包</span></a></nav><div class=comment-head>评论 & Email：</div><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：12. 自定义类型和结构体 - 定义 on x" href="https://x.com/intent/tweet/?text=@laomiao_ Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a12.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e5%ae%9a%e4%b9%89&amp;url=https%3a%2f%2fwww.gby.ai%2fgolang-struct%2f&amp;hashtags="><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 50 50" fill="currentcolor"><path d="M5.9199219 6 20.582031 27.375 6.2304688 44H9.4101562L21.986328 29.421875 31.986328 44H44L28.681641 21.669922 42.199219 6H39.029297L27.275391 19.617188 17.933594 6H5.9199219zm3.796875 2H16.880859L40.203125 42H33.039062L9.7167969 8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go基础系列：12. 自定义类型和结构体 - 定义 on email" href="mailto:mglluoye@gmail.com?subject=Go%e5%9f%ba%e7%a1%80%e7%b3%bb%e5%88%97%ef%bc%9a12.%20%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93%20-%20%e5%ae%9a%e4%b9%89"><svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447 4.92893 2 7.28595 2 12 2c4.714.0 7.0711.0 8.5355 1.46447C22 4.92893 22 7.28595 22 12c0 4.714.0 7.0711-1.4645 8.5355C19.0711 22 16.714 22 12 22c-4.71405.0-7.07107.0-8.53553-1.4645C2 19.0711 2 16.714 2 12z" stroke="currentcolor" stroke-width="1.5"/><path d="M2 13H5.16026c.90517.0 1.35776.0 1.75558.183.39783.1829.69237.5266 1.28145 1.2138L8.80271 15.1032C9.39179 15.7904 9.68633 16.1341 10.0842 16.317 10.482 16.5 10.9346 16.5 11.8397 16.5H12.1603C13.0654 16.5 13.518 16.5 13.9158 16.317 14.3137 16.1341 14.6082 15.7904 15.1973 15.1032L15.8027 14.3968C16.3918 13.7096 16.6863 13.3659 17.0842 13.183 17.482 13 17.9346 13 18.8397 13H22" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M8 7h8" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/><path d="M10 10.5h4" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round"/></svg></a></div></footer></article></main><footer class=footer><span>Content under license <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>